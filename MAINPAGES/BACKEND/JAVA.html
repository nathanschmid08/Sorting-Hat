<!DOCTYPE html>
<html lang="de">

<head>
    <title>JAVA</title>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary-color: #3b82f6;
            --hover-color: #E15241;
            --bg-primary: #1e1e1e;
            --bg-secondary: #141414;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2d2d2d;
        }

        html, body {
            background-color: #1e1e1e !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Dela Gothic One', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        header {
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            padding: 3rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        header img {
            height: 80px;
            width: 80px;
            object-fit: contain;
            border-radius: 12px;
        }

        header h1 {
            font-size: 3rem;
            color: var(--text-primary);
            font-weight: normal;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sticky-nav-container {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
        }

        .nav-scroll-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            padding: 0 1rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .nav-scroll-btn:hover {
            color: var(--primary-color);
        }

        .nav-wrapper {
            overflow-x: auto;
            white-space: nowrap;
            flex: 1;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .nav-wrapper::-webkit-scrollbar {
            display: none;
        }

        nav ul {
            display: inline-flex;
            list-style: none;
            gap: 1rem;
            padding: 0 1rem;
        }

        nav a {
            text-decoration: none;
            color: var(--text-primary);
            font-size: 0.85rem;
            padding: 0.4rem 0.75rem;
            border-radius: 0.25rem;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        nav a:hover {
            color: var(--primary-color);
        }

        main {
            padding: 2rem;
        }

        main h1 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        main h2 {
            margin-top: 2rem;
            font-size: 1.5rem;
            color: var(--hover-color);
        }

        main p {
            margin-top: 1rem;
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
            font-family: 'Source Sans 3', sans-serif;
        }

        main a {
            color: #ffff;
            text-decoration: none;
        }

        .hljs,
        .hljs * {
            background: none !important;
        }

        pre {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            margin-top: 1rem;
        }

        code {
            font-family: monospace;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
    </style>
</head>

<body>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <header>
        <img src="LOGO/java.png" alt="">
        <h1>Java</h1>
    </header>
    <div class="sticky-nav-container">
        <button class="nav-scroll-btn" onclick="scrollNav(-200)">&#x25C0;</button>
        <div class="nav-wrapper" id="navWrapper">
            <nav>
                <ul>
                    <li><a href="#intro">Einführung</a></li>
                    <li><a href="#installation">Installation und Einrichtung</a></li>
                    <li><a href="#syntax">Grundlegende Syntax</a></li>
                    <li><a href="#vardat">Variablen und Datentypen</a></li>
                    <li><a href="#Operatoren">Operatoren</a></li>
                    <li><a href="#Kontrollstrukturen">Kontrollstrukturen</a></li>
                    <li><a href="#Schleifen">Schleifen</a></li>
                    <li><a href="#Arrays">Arrays</a></li>
                    <li><a href="#Methoden">Methoden</a></li>
                    <li><a href="#classobj">Klassen und Objekte</a></li>
                    <li><a href="#oop">Einführung in OOP</a></li>
                    <li><a href="#Vererbung">Vererbung</a></li>
                    <li><a href="#Polymorphismus">Polymorphismus</a></li>
                    <li><a href="#abstrcla">Abstrakte Klassen</a></li>
                    <li><a href="#Interfaces">Interfaces</a></li>
                    <li><a href="#packimp">Pakete und Importe</a></li>
                    <li><a href="#exchand">Exception Handling</a></li>
                    <li><a href="#datverarb">Dateiverarbeitung</a></li>
                    <li><a href="#collframe">Collections Framework</a></li>
                    <li><a href="#Generics">Generics</a></li>
                    <li><a href="#Lambda-Ausdrücke">Lambda-Ausdrücke</a></li>
                    <li><a href="#streamapi">Streams API</a></li>
                    <li><a href="#Multithreading">Multithreading</a></li>
                    <li><a href="#jdbcon">Java Database Connectivity</a></li>
                    <li><a href="#junite">JUnit Testing</a></li>
                    <li><a href="#JavaFX">JavaFX</a></li>
                    <li><a href="#JSP">Servlets und JSP</a></li>
                    <li><a href="#Spring">Spring Framework</a></li>
                    <li><a href="#Maven">Maven</a></li>
                </ul>
            </nav>
        </div>
        <button class="nav-scroll-btn" onclick="scrollNav(200)">&#x25B6;</button>
    </div>

    <main>
        <h1 id="intro">Einführung</h1>
        <p>Java ist eine objektorientierte Programmiersprache, die nach dem Prinzip „Einmal schreiben, überall ausführen“ entwickelt wurde. 
            Sie wird nicht direkt vom Betriebssystem ausgeführt, sondern läuft in der Java Virtual Machine (JVM), was sie plattformunabhängig macht. 
            Java kommt in vielen Bereichen zum Einsatz – von Unternehmenssoftware über Android-Apps bis hin zu Webanwendungen. 
            Die Sprache legt viel Wert auf Stabilität, Sicherheit und Wartbarkeit, was sie besonders für grosse, langfristige Projekte attraktiv macht. 
            Durch ihre klare Struktur und umfangreiche Standardbibliothek ist Java bis heute eine der meistgenutzten Programmiersprachen weltweit.
        </p>
        <h2>Beispiel</h2>  
        <pre class="language-java"><code>
public class HalloWelt {
    public static void main(String[] args) {
        System.out.println("Hallo, Welt!");
    }
}       
        </code></pre>    

        <br>
        <br>
        <br>
        
        <h1 id="installation">Installation und Einrichtung</h1>
        <p>
            Um mit Java programmieren zu können, musst du zuerst das <strong>JDK (Java Development Kit)</strong> installieren.
            Es enthält alles, was du brauchst: den Compiler, die Laufzeitumgebung und wichtige Werkzeuge.
        </p>
          
        <h2>1. Java herunterladen</h2>
        <p>
            Die einfachste Möglichkeit ist der Download von der offiziellen <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank">Oracle-Webseite</a>.
            Alternativ kannst du auch die freie und weit verbreitete Version von <a href="https://adoptium.net/" target="_blank">Adoptium</a> verwenden.
            Wähle dort einfach dein Betriebssystem aus (z. B. Windows, macOS oder Linux) und lade das <strong>JDK 17 (LTS)</strong> herunter – diese Version ist stabil und ideal für Einsteiger.
        </p>
          
        <h2>2. Java installieren</h2>
        <p>
            Nach dem Download kannst du das JDK ganz einfach installieren:
        </p>
        <p><strong>Windows / macOS:</strong> Installiere es über einen Doppelklick und folge dem Assistenten.</p>
        <p><strong>Linux (z. B. Ubuntu):</strong> Öffne ein Terminal und gib folgenden Befehl ein:</p>
        
        <br>
        
        <pre class="language-bash"><code>
sudo apt install openjdk-17-jdk
        </code></pre>
            
          
        <h2>3. Installation überprüfen</h2>
        <p>
            Öffne ein Terminal oder die Eingabeaufforderung und gib folgendes ein:
            <code>java -version</code><br>
            Wenn du eine Ausgabe wie <code>java version "17.0.x"</code> siehst, ist alles korrekt installiert.
        </p>
          
        <h2>Welche IDE ist empfehlenswert?</h2>
        <p>
            Für Einsteiger ist <strong>IntelliJ IDEA Community Edition</strong> besonders geeignet. 
            Sie ist kostenlos, leicht verständlich und bietet viele Funktionen wie Autovervollständigung, Fehlererkennung und ein übersichtliches Projektmanagement.
            Du kannst sie direkt von der offiziellen Seite herunterladen:
            <a href="https://www.jetbrains.com/idea/download" target="_blank">IntelliJ Download</a>.
        </p>
          
        <p>
            Alternativ kannst du auch <strong>Eclipse</strong> oder <strong>NetBeans</strong> verwenden, die ebenfalls kostenlose und funktionsreiche Entwicklungsumgebungen für Java sind.
        </p>
          
        <h2>Erstes Java-Programm</h2>
        <p>
            Sobald die IDE eingerichtet ist, kannst du ein neues Java-Projekt erstellen und folgenden Code ausprobieren:
        </p>
        <pre><code class="language-java">
public class Main {
    public static void main(String[] args) {
        System.out.println("Hallo, Java!");
    }
}
        </code></pre>
        <p>
            Klicke in der IDE auf den &#x25B6; Button, um das Programm zu starten. Schon wird dein erstes Java-Programm in der Konsole ausgegeben!
        </p>

        <br>
        <br>
        <br>

        <h1 id="syntax">Grundlegende Syntax</h1>
        <p>
            Java ist eine streng typisierte, objektorientierte Programmiersprache, bei der jedes Programm in Klassen strukturiert ist. 
            Der Einstiegspunkt jedes Programms ist die Methode <code>main()</code>, in der der auszuführende Code steht. 
            Java verwendet geschweifte Klammern <code>{ }</code> zur Abgrenzung von Codeblöcken und ein Semikolon <code>;</code> am Ende jeder Anweisung. 
            Variablen müssen mit einem Datentyp deklariert werden, und Methoden dienen dazu, Code logisch zu strukturieren und wiederzuverwenden.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class HalloWelt {

    // Haupteinstiegspunkt des Programms
    public static void main(String[] args) {
        // Gibt eine Textzeile aus
        System.out.println("Hallo, Welt!");
            
        // Deklariert eine Ganzzahl-Variable
        int zahl = 10;
            
        // Bedingte Ausgabe basierend auf der Zahl
        if (zahl > 5) {
            System.out.println("Die Zahl ist grösser als 5.");
        } else {
            System.out.println("Die Zahl ist 5 oder kleiner.");
        }
            
        // Eine einfache Schleife von 0 bis 4
        for (int i = 0; i &lt; 5; i++) {
            System.out.println("Zähler: " + i);
        }
    }
}      
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="vardat">Variablen und Datentypen</h1>
        <p>
            In Java müssen Variablen immer mit einem Datentyp deklariert werden, der bestimmt, welche Art von Wert gespeichert werden kann. 
            Es gibt primitive Datentypen wie <code>int</code> (Ganzzahlen), <code>double</code> (Gleitkommazahlen), <code>boolean</code> (wahr oder falsch) und <code>char</code> (ein einzelnes Zeichen). 
            Zusätzlich gibt es Referenzdatentypen wie <code>String</code>, die auf Objekte verweisen. 
            Durch die klare Typisierung sorgt Java für Sicherheit und Vorhersagbarkeit im Code. Variablen lassen sich mit einem Startwert initialisieren oder später befüllen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class DatentypenBeispiel {

    public static void main(String[] args) {
        // Einfache Zahl (Ganzzahl)
        int alter = 16;
            
        // Kommazahl
        double temperatur = 36.6;
            
        // Wahrheitswert
        boolean istVolljährig = false;
            
        // Ein einzelnes Zeichen
        char geschlecht = 'm';
            
        // Ein Text (String ist eine Klasse, kein primitiver Typ)
        String name = "Nathan";
            
        // Ausgabe der Variablen
        System.out.println("Name: " + name);
        System.out.println("Alter: " + alter);
        System.out.println("Temperatur: " + temperatur);
        System.out.println("Geschlecht: " + geschlecht);
        System.out.println("Ist volljährig? " + istVolljährig);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Operatoren">Operatoren</h1>
        <p>
            Java bietet verschiedene Operatoren, mit denen du Werte verarbeiten, vergleichen oder logisch verknüpfen kannst. 
            Zu den wichtigsten zählen <strong>arithmetische Operatoren</strong> wie <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> und <code>%</code> (Rest), 
            <strong>Vergleichsoperatoren</strong> wie <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> 
            sowie <strong>logische Operatoren</strong> wie <code>&amp;&amp;</code> (und), <code>||</code> (oder) und <code>!</code> (nicht). 
            Operatoren sind ein zentraler Bestandteil jeder Programmlogik und werden häufig in Bedingungen und Berechnungen verwendet.
        </p>
        <pre class="language-java"><code>
public class OperatorenBeispiel {

    public static void main(String[] args) {
        // Arithmetische Operatoren
        int a = 10;
        int b = 3;

        System.out.println("Addition: " + (a + b));         // 13
        System.out.println("Subtraktion: " + (a - b));      // 7
        System.out.println("Multiplikation: " + (a * b));   // 30
        System.out.println("Division: " + (a / b));         // 3 (Ganzzahldivision!)
        System.out.println("Rest: " + (a % b));             // 1

        // Vergleichsoperatoren
        System.out.println("a == b: " + (a == b));          // false
        System.out.println("a != b: " + (a != b));          // true
        System.out.println("a > b: " + (a > b));            // true
        System.out.println("a &lt;= b: " + (a &lt;= b));          // false

        // Logische Operatoren
        boolean x = true;
        boolean y = false;

        System.out.println("x && y: " + (x && y));          // false
        System.out.println("x || y: " + (x || y));          // true
        System.out.println("!x: " + (!x));                  // false

        // Zuweisungsoperator
        int zahl = 5;
        zahl += 3; // entspricht: zahl = zahl + 3;
        System.out.println("zahl nach += 3: " + zahl);      // 8
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Kontrollstrukturen">Kontrollstrukturen</h1>
        <p>
            Kontrollstrukturen bestimmen, in welcher Reihenfolge Anweisungen ausgeführt werden. 
            Mit <code>if</code>, <code>else if</code> und <code>else</code> lassen sich Entscheidungen abhängig von Bedingungen treffen. 
            Die <code>switch</code>-Struktur ist eine Alternative zu vielen <code>if</code>-Blöcken, wenn man mehrere mögliche Werte vergleichen möchte. 
            Für wiederholte Ausführungen kommen Schleifen wie <code>for</code>, <code>while</code> und <code>do-while</code> zum Einsatz. 
            Sie ermöglichen es, Code mehrfach auszuführen – entweder eine festgelegte Anzahl an Durchläufen oder solange eine Bedingung erfüllt ist.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class KontrollstrukturenBeispiel {

    public static void main(String[] args) {

        // if-else: einfache Bedingung
        int alter = 16;
        if (alter >= 18) {
            System.out.println("Du bist volljährig.");
        } else {
            System.out.println("Du bist minderjährig.");
        }

        // switch: mehrere Optionen prüfen
        int tag = 3;
        switch (tag) {
            case 1:
                System.out.println("Montag");
                break;
            case 2:
                System.out.println("Dienstag");
                break;
            case 3:
                System.out.println("Mittwoch");
                break;
            default:
                System.out.println("Unbekannter Tag");
        }

        // for-Schleife: zählt von 0 bis 4
        for (int i = 0; i &lt; 5; i++) {
            System.out.println("for-Zähler: " + i);
        }

        // while-Schleife: läuft, solange die Bedingung wahr ist
        int zähler = 3;
        while (zähler > 0) {
            System.out.println("while-Zähler: " + zähler);
            zähler--;
        }

        // do-while: läuft mindestens einmal
        int x = 0;
        do {
            System.out.println("do-while läuft mindestens einmal.");
            x++;
        } while (x &lt; 1);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Schleifen">Schleifen</h1>
        <p>
            Schleifen in Java ermöglichen es dir, bestimmte Codeabschnitte mehrfach auszuführen. 
            Die <code>for</code>-Schleife eignet sich gut, wenn du eine bekannte Anzahl von Durchläufen hast, z.&nbsp;B. beim Zählen. 
            Die <code>while</code>-Schleife wiederholt einen Block, solange eine Bedingung erfüllt ist. 
            Die <code>do-while</code>-Schleife funktioniert ähnlich, wird aber mindestens einmal ausgeführt – auch wenn die Bedingung von Anfang an falsch ist. 
            Schleifen sind ein zentrales Werkzeug, um Wiederholungen effizient und übersichtlich umzusetzen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class SchleifenBeispiel {

    public static void main(String[] args) {

        // for-Schleife: läuft 5-mal (von 0 bis 4)
        System.out.println("for-Schleife:");
        for (int i = 0; i &lt; 5; i++) {
            System.out.println("Durchlauf " + i);
        }

        // while-Schleife: läuft, solange zähler > 0 ist
        System.out.println("\nwhile-Schleife:");
        int zähler = 3;
        while (zähler > 0) {
            System.out.println("Zähler ist: " + zähler);
            zähler--;
        }

        // do-while-Schleife: wird mindestens einmal ausgeführt
        System.out.println("\ndo-while-Schleife:");
        int x = 0;
        do {
            System.out.println("Dies wird mindestens einmal ausgegeben.");
            x++;
        } while (x &lt; 1);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Arrays">Arrays</h1>
        <p>
            Ein Array ist eine Datenstruktur, mit der du mehrere Werte desselben Typs unter einem gemeinsamen Namen speichern kannst. 
            Jedes Element im Array hat einen festen Index, beginnend bei 0. Arrays haben eine feste Länge, die beim Erstellen festgelegt wird. 
            Du kannst sie sowohl direkt mit Werten befüllen als auch leer initialisieren und später füllen. 
            Sie sind besonders praktisch, wenn du mit vielen ähnlichen Daten arbeiten musst – etwa eine Liste von Zahlen, Namen oder Objekten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class ArrayBeispiel {

    public static void main(String[] args) {

        // Array mit fester Länge deklarieren und später befüllen
        int[] zahlen = new int[3];
        zahlen[0] = 10;
        zahlen[1] = 20;
        zahlen[2] = 30;

        // Direktes Initialisieren eines Arrays mit Werten
        String[] namen = {"Anna", "Ben", "Clara"};

        // Zugriff auf einzelne Elemente
        System.out.println("Zweite Zahl: " + zahlen[1]); // 20
        System.out.println("Erster Name: " + namen[0]);  // Anna

        // Länge eines Arrays mit .length
        System.out.println("Anzahl der Namen: " + namen.length);

        // Durchlaufen eines Arrays mit einer for-Schleife
        System.out.println("\nAlle Zahlen im Array:");
        for (int i = 0; i &lt; zahlen.length; i++) {
            System.out.println("Index " + i + ": " + zahlen[i]);
        }

        // Alternativ: for-each-Schleife
        System.out.println("\nAlle Namen im Array:");
        for (String name : namen) {
            System.out.println(name);
        }
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Methoden">Methoden</h1>
        <p>
            Methoden sind wiederverwendbare Codeblöcke, die bestimmte Aufgaben ausführen. 
            Sie helfen dir dabei, deinen Code zu strukturieren und zu vermeiden, dass du dieselbe Logik mehrfach schreiben musst. 
            Eine Methode kann Parameter entgegennehmen, Anweisungen ausführen und optional einen Rückgabewert liefern. 
            Die <code>main</code>-Methode ist der Startpunkt eines Java-Programms, aber du kannst beliebig viele eigene Methoden definieren, um deinen Code übersichtlicher und modularer zu gestalten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class MethodenBeispiel {

    public static void main(String[] args) {
        // Methode ohne Rückgabewert aufrufen
        begruessung("Nathan");

        // Methode mit Rückgabewert aufrufen
        int ergebnis = addiere(5, 7);
        System.out.println("5 + 7 = " + ergebnis);

        // Mehrere Aufrufe möglich
        System.out.println("8 + 3 = " + addiere(8, 3));
    }

    // Eine Methode mit einem Parameter und ohne Rückgabewert (void)
    public static void begruessung(String name) {
        System.out.println("Hallo, " + name + "!");
    }

    // Eine Methode mit zwei Parametern und einem Rückgabewert
    public static int addiere(int a, int b) {
        return a + b;
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="classobj">Klassen und Objekte</h1>
        <p>
            Klassen und Objekte sind das Herz der objektorientierten Programmierung in Java. 
            Eine <strong>Klasse</strong> ist eine Vorlage (Blueprint) für ein Objekt – sie beschreibt, wie ein Objekt aufgebaut ist (Attribute) und was es tun kann (Methoden). 
            Ein <strong>Objekt</strong> ist eine konkrete Instanz einer Klasse. 
            Mit Klassen kannst du reale Dinge wie "Auto", "Benutzer" oder "Bankkonto" in Code abbilden. 
            Du definierst eine Klasse einmal, kannst aber beliebig viele Objekte davon erzeugen – jedes mit eigenen Werten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
// Klassendefinition
public class Auto {

    // Attribute (Eigenschaften)
    String marke;
    int baujahr;

    // Konstruktor: wird beim Erstellen eines Objekts aufgerufen
    public Auto(String marke, int baujahr) {
        this.marke = marke;
        this.baujahr = baujahr;
    }

    // Methode: gibt Info über das Auto aus
    public void beschreibe() {
        System.out.println("Marke: " + marke + ", Baujahr: " + baujahr);
    }
}


// Hauptklasse mit main-Methode
public class AutoDemo {

    public static void main(String[] args) {
        // Erstes Objekt erstellen
        Auto meinAuto = new Auto("BMW", 2021);
        meinAuto.beschreibe();  // Ausgabe: Marke: BMW, Baujahr: 2021

        // Zweites Objekt erstellen
        Auto deinAuto = new Auto("Toyota", 2018);
        deinAuto.beschreibe();  // Ausgabe: Marke: Toyota, Baujahr: 2018
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="oop">Einführung in OOP</h1>
        <p>
            Die objektorientierte Programmierung (OOP) ist ein zentrales Konzept in Java. Sie ermöglicht es, Software in modularen, wiederverwendbaren und gut strukturierten Komponenten zu organisieren. 
            Statt den Code rein prozedural (Schritt für Schritt) zu schreiben, denkst du bei OOP in <strong>Objekten</strong> – also an Dinge, die bestimmte Eigenschaften (Attribute) besitzen und bestimmte Dinge tun können (Methoden).
        </p>
        <p>
            Der Grundbaustein ist die <strong>Klasse</strong>, die als Vorlage für Objekte dient. Ein Objekt ist eine konkrete Instanz dieser Klasse. 
            Durch <strong>Vererbung</strong> können Klassen von anderen Klassen erben – das spart Code und ermöglicht Spezialisierung. 
            Weitere wichtige OOP-Konzepte sind <strong>Polymorphismus</strong> (gleiche Schnittstelle, unterschiedliche Umsetzung) und <strong>Kapselung</strong> (Daten verbergen und nur kontrolliert zugänglich machen).
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Tier.java</h3>
        <pre class="language-java"><code>
// Tier ist eine allgemeine Klasse, von der andere Tiere erben können
public class Tier {

    // geschützte Attribute (nur innerhalb Klasse oder Unterklasse sichtbar)
    protected String name;
    protected int alter;

    // Konstruktor
    public Tier(String name, int alter) {
        this.name = name;
        this.alter = alter;
    }

    // Methode, die von Unterklassen überschrieben werden kann
    public void gibLaut() {
        System.out.println("Ein Tier macht ein Geräusch.");
    }

    // Getter-Methode (Kapselung)
    public String getName() {
        return name;
    }

    public int getAlter() {
        return alter;
    }
}
        </code></pre>
        <br>
        <h3>Unterklassen: Hund.java & Katze.java</h3>
        <pre class="language-java"><code>
public class Hund extends Tier {

    public Hund(String name, int alter) {
        super(name, alter); // ruft den Konstruktor der Oberklasse auf
    }

    // Überschreibt die Methode gibLaut()
    @Override
    public void gibLaut() {
        System.out.println(name + " bellt: Wuff!");
    }

    public void apportieren() {
        System.out.println(name + " bringt den Ball zurück.");
    }
}
        </code></pre>
        <br>
        <pre class="language-java"><code>
public class Katze extends Tier {

    public Katze(String name, int alter) {
        super(name, alter);
    }

    @Override
    public void gibLaut() {
        System.out.println(name + " miaut: Miau!");
    }

    public void schnurren() {
        System.out.println(name + " schnurrt zufrieden.");
    }
}
        </code></pre>
        <br>
        <h3>Hauptprogramm: TierDemo.java</h3>
        <pre class="language-java"><code>
public class TierDemo {

    public static void main(String[] args) {
        // Objekte erstellen
        Hund hund = new Hund("Rex", 5);
        Katze katze = new Katze("Luna", 3);

        // Methoden aufrufen
        hund.gibLaut();       // Rex bellt: Wuff!
        hund.apportieren();   // Rex bringt den Ball zurück.

        katze.gibLaut();      // Luna miaut: Miau!
        katze.schnurren();    // Luna schnurrt zufrieden.

        // Polymorphismus: beide sind vom Typ Tier
        Tier[] tiere = {hund, katze};

        System.out.println("\nAlle Tiere machen ein Geräusch:");
        for (Tier t : tiere) {
            t.gibLaut();  // Ruft je nach Objekt die passende Methode auf
        }
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Vererbung">Vererbung</h1>
        <p>
            Vererbung ist ein zentrales Konzept der objektorientierten Programmierung in Java. 
            Sie erlaubt es, eine neue Klasse auf Basis einer bestehenden Klasse zu erstellen. 
            Die neue Klasse – auch <strong>Subklasse</strong> oder <strong>Kindklasse</strong> genannt – erbt alle öffentlichen und geschützten Eigenschaften (Attribute und Methoden) der <strong>Oberklasse</strong> (auch Superklasse genannt). 
            So können gemeinsame Funktionalitäten wiederverwendet und spezialisierte Funktionen hinzugefügt oder angepasst werden. 
            In Java wird Vererbung mit dem Schlüsselwort <code>extends</code> realisiert. 
            Vererbung spart Code, fördert Wiederverwendbarkeit und unterstützt Polymorphismus.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Oberklasse: Fahrzeug.java</h3>
        <pre class="language-java"><code>
public class Fahrzeug {

    protected String marke;
    protected int baujahr;

    // Konstruktor
    public Fahrzeug(String marke, int baujahr) {
        this.marke = marke;
        this.baujahr = baujahr;
    }

    // Eine allgemeine Methode
    public void starteMotor() {
        System.out.println("Der Motor des Fahrzeugs startet.");
    }

    public void info() {
        System.out.println("Fahrzeug: " + marke + " (" + baujahr + ")");
    }
}
        </code></pre>
        <br>
        <h3>Subklasse: Auto.java</h3>
        <pre class="language-java"><code>
public class Auto extends Fahrzeug {

    private int anzahlTueren;

    public Auto(String marke, int baujahr, int anzahlTueren) {
        super(marke, baujahr); // Konstruktor der Oberklasse wird aufgerufen
        this.anzahlTueren = anzahlTueren;
    }

    @Override
    public void starteMotor() {
        System.out.println("Das Auto " + marke + " startet mit einem Zündschlüssel.");
    }

    public void oeffneKofferraum() {
        System.out.println("Der Kofferraum wird geöffnet.");
    }
}
        </code></pre>
        <br>
        <h3>Subklasse: Motorrad.java</h3>
        <pre class="language-java"><code>
public class Motorrad extends Fahrzeug {

    private boolean hatBeiwagen;

    public Motorrad(String marke, int baujahr, boolean hatBeiwagen) {
        super(marke, baujahr);
        this.hatBeiwagen = hatBeiwagen;
    }

    @Override
    public void starteMotor() {
        System.out.println("Das Motorrad " + marke + " wird mit einem Kickstart gestartet.");
    }

    public void zeigeBeiwagenStatus() {
        if (hatBeiwagen) {
            System.out.println("Dieses Motorrad hat einen Beiwagen.");
        } else {
            System.out.println("Dieses Motorrad hat keinen Beiwagen.");
        }
    }
}
        </code></pre>
        <br>
        <h3>Hauptklasse: VererbungsDemo.java</h3>
        <pre class="language-java"><code>
public class VererbungsDemo {

    public static void main(String[] args) {
        Auto meinAuto = new Auto("VW Golf", 2015, 5);
        Motorrad meinMotorrad = new Motorrad("Harley", 2020, false);

        // Methoden aus der Oberklasse
        meinAuto.info();                            // Fahrzeug: VW Golf (2015)
        meinMotorrad.info();                        // Fahrzeug: Harley (2020)

        // Überschriebene Methode
        meinAuto.starteMotor();                     // Das Auto VW Golf startet mit einem Zündschlüssel.
        meinMotorrad.starteMotor();                 // Das Motorrad Harley wird mit einem Kickstart gestartet.

        // Eigene Methoden der Kindklassen
        meinAuto.oeffneKofferraum();                // Der Kofferraum wird geöffnet.
        meinMotorrad.zeigeBeiwagenStatus();         // Dieses Motorrad hat keinen Beiwagen.
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Polymorphismus">Polymorphismus</h1>
        <p>
            Polymorphismus ist ein zentrales Prinzip der objektorientierten Programmierung. Das Wort stammt aus dem Griechischen und bedeutet „vielgestaltig“. 
            In Java bedeutet Polymorphismus, dass eine Methode abhängig vom tatsächlichen Objekttyp unterschiedlich reagieren kann – selbst wenn der Referenztyp ein gemeinsamer Obertyp ist. 
            So können unterschiedliche Klassen eine Methode wie <code>ausgabe()</code> auf eigene Weise umsetzen, aber über eine gemeinsame Schnittstelle angesprochen werden. 
            Das ermöglicht es, flexiblen, erweiterbaren und leicht wartbaren Code zu schreiben – denn du kannst mit einem gemeinsamen Typ (z. B. einer Oberklasse) arbeiten, ohne jede Spezialisierung zu kennen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Oberklasse: Tier.java</h3>
        <pre class="language-java"><code>
public class Tier {

    protected String name;

    public Tier(String name) {
        this.name = name;
    }

    // Methode, die von Unterklassen überschrieben werden kann
    public void gibLaut() {
        System.out.println("Ein Tier macht ein Geräusch.");
    }

    public void beschreibe() {
        System.out.println("Das Tier heisst " + name + ".");
    }
}
        </code></pre>
        <br>
        <h3>Unterklassen</h3>
        <pre class="language-java"><code>
public class Hund extends Tier {
    public Hund(String name) {
        super(name);
    }

    @Override
    public void gibLaut() {
        System.out.println(name + " bellt: Wuff!");
    }
}
        </code></pre>
        <br>
        <pre class="language-java"><code>
public class Katze extends Tier {
    public Katze(String name) {
        super(name);
    }

    @Override
    public void gibLaut() {
        System.out.println(name + " miaut: Miau!");
    }
}
        </code></pre>
        <br>
        <h3>Hauptklasse mit Polymorphismus</h3>
        <pre class="language-java"><code>
public class TierDemo {

    public static void main(String[] args) {
        // Tier-Referenzen, aber unterschiedliche Objekte
        Tier[] tiere = {
            new Hund("Bello"),
            new Katze("Miezi"),
            new Hund("Rex")
        };

        // Polymorphes Verhalten: gibLaut() reagiert je nach Objekt anders
        for (Tier tier : tiere) {
            tier.beschreibe();   // Gemeinsame Methode
            tier.gibLaut();      // Unterschiedliches Verhalten – Polymorphismus!
            System.out.println("---");
        }
    }
}
        </code></pre>
        <br>
        <h3>Ausgabe</h3>
        <pre class="language-yaml"><code>
Das Tier heisst Bello.
Bello bellt: Wuff!
---
Das Tier heisst Miezi.
Miezi miaut: Miau!
---
Das Tier heisst Rex.
Rex bellt: Wuff!
---
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="abstrcla">Abstrakte Klassen</h1>
        <p>
            Eine <strong>abstrakte Klasse</strong> in Java ist eine Klasse, die nicht direkt instanziiert werden kann. 
            Sie dient als Vorlage für andere Klassen und kann sowohl konkrete (fertig implementierte) als auch abstrakte (nur deklarierte) Methoden enthalten. 
            Abstrakte Methoden besitzen keinen Methodenkörper – sie müssen von Unterklassen überschrieben werden. 
            Abstrakte Klassen helfen dabei, gemeinsame Funktionalitäten zu definieren und gleichzeitig bestimmte Methoden zur Implementierung in den Unterklassen zu erzwingen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Abstrakte Oberklasse: Form.java</h3>
        <pre class="language-java"><code>
public abstract class Form {

    protected String name;

    public Form(String name) {
        this.name = name;
    }

    // Konkrete Methode
    public void beschreibe() {
        System.out.println("Dies ist eine Form: " + name);
    }

    // Abstrakte Methode – muss von Unterklassen implementiert werden
    public abstract double berechneFlaeche();
}
        </code></pre>
        <br>
        <h3>Unterklasse: Kreis.java</h3>
        <pre class="language-java"><code>
public class Kreis extends Form {

    private double radius;

    public Kreis(double radius) {
        super("Kreis");
        this.radius = radius;
    }

    @Override
    public double berechneFlaeche() {
        return Math.PI * radius * radius;
    }
}
        </code></pre>
        <br>
        <h3>Unterklasse: Rechteck.java</h3>
        <pre class="language-java"><code>
public class Rechteck extends Form {

    private double breite;
    private double hoehe;

    public Rechteck(double breite, double hoehe) {
        super("Rechteck");
        this.breite = breite;
        this.hoehe = hoehe;
    }

    @Override
    public double berechneFlaeche() {
        return breite * hoehe;
    }
}
        </code></pre>
        <br>
        <h3>Hauptklasse: FormDemo.java</h3>
        <pre class="language-java"><code>
public class FormDemo {

    public static void main(String[] args) {
        // Polymorphie mit abstrakter Klasse
        Form[] formen = {
            new Kreis(3.5),
            new Rechteck(4.0, 2.5)
        };

        for (Form form : formen) {
            form.beschreibe();
            System.out.println("Fläche: " + form.berechneFlaeche());
            System.out.println("---");
        }
    }
}
        </code></pre>
        <h3>Ausgabe</h3>
        <pre class="language-yaml"><code>
Dies ist eine Form: Kreis
Fläche: 38.48451000647496
---
Dies ist eine Form: Rechteck
Fläche: 10.0
---
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Interfaces">Interfaces</h1>
        <p>
            Ein <strong>Interface</strong> ist eine Sammlung von Methodensignaturen, die von einer Klasse implementiert werden müssen. 
            Im Gegensatz zu abstrakten Klassen enthält ein Interface (in seiner ursprünglichen Form) keine konkreten Implementierungen – es definiert nur, <em>was</em> eine Klasse können muss, nicht <em>wie</em> sie es tut. 
            Interfaces ermöglichen es, verschiedene Klassen zu vereinheitlichen, auch wenn sie nicht von derselben Oberklasse erben. 
            Eine Klasse kann beliebig viele Interfaces implementieren – damit ist Mehrfachvererbung in Java möglich (im Gegensatz zu Klassenvererbung).
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Interface: Geraet.java</h3>
        <pre class="language-java"><code>
public interface Geraet {
    void einschalten();
    void ausschalten();
}
        </code></pre>
        <br>
        <h3>Klasse Fernseher</h3>
        <pre class="language-java"><code>
public class Fernseher implements Geraet {

    @Override
    public void einschalten() {
        System.out.println("Fernseher wird eingeschaltet.");
    }

    @Override
    public void ausschalten() {
        System.out.println("Fernseher wird ausgeschaltet.");
    }
}
        </code></pre>
        <br>
        <h3>Klasse Radio</h3>
        <pre class="language-java"><code>
public class Radio implements Geraet {

    @Override
    public void einschalten() {
        System.out.println("Radio spielt Musik.");
    }

    @Override
    public void ausschalten() {
        System.out.println("Radio geht aus.");
    }
}
        </code></pre>
        <br>
        <h3>Hauptklasse</h3>
        <pre class="language-java"><code>
public class GeraetDemo {

    public static void main(String[] args) {
        Geraet[] geraete = {
            new Fernseher(),
            new Radio()
        };

        for (Geraet g : geraete) {
            g.einschalten();
            g.ausschalten();
            System.out.println("---");
        }
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="packimp">Pakete und Importe</h1>
        <p>
            In Java dienen <strong>Pakete (Packages)</strong> dazu, Klassen logisch zu gruppieren und die Übersicht in grösseren Projekten zu verbessern. 
            Ein Paket entspricht dabei einem Ordner im Dateisystem. 
            Mit dem <code>package</code>-Schlüsselwort gibst du am Anfang einer Datei an, zu welchem Paket eine Klasse gehört. 
            Um Klassen aus anderen Paketen zu verwenden, nutzt du das <code>import</code>-Schlüsselwort. 
            Das fördert Struktur, verhindert Namenskonflikte und erleichtert die Wiederverwendbarkeit von Code.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Dateistruktur</h3>
        <pre><code>
projekt/
├── app/
│   └── Main.java
└── util/
    └── Rechner.java
        </code></pre>
        <br>
        <h3>util/Rechner.java</h3>
        <pre class="language-java"><code>
package util;  // Das Paket heisst "util"

public class Rechner {

    public static int addiere(int a, int b) {
        return a + b;
    }

    public static int multipliziere(int a, int b) {
        return a * b;
    }
}
        </code></pre>
        <br>
        <h3>app/Main.java</h3>
        <pre class="language-java"><code>
package app; // Das Paket heisst "app"

import util.Rechner;  // Importiert die Klasse Rechner aus dem Paket "util"

public class Main {
    public static void main(String[] args) {
        int summe = Rechner.addiere(5, 3);
        int produkt = Rechner.multipliziere(4, 7);

        System.out.println("Summe: " + summe);
        System.out.println("Produkt: " + produkt);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="exchand">Exception Handling</h1>
        <p>
            Das <strong>Exception Handling</strong> ermöglicht es dir, Fehler und unerwartete Situationen während der Programmausführung kontrolliert zu behandeln. 
            Anstatt dass das Programm bei einem Fehler sofort abstürzt, kannst du mit <code>try</code>, <code>catch</code> und <code>finally</code> Blöcken gezielt reagieren. 
            So kannst du z. B. fehlgeschlagene Eingaben abfangen, Ressourcen sauber freigeben oder eigene Fehlerklassen definieren. 
            Mit Exception Handling schreibst du robusteren und stabileren Code, der auch in problematischen Situationen sinnvoll reagiert.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
public class ExceptionDemo {

    public static void main(String[] args) {
        try {
            // Versuch: Division durch Null - führt zu einer ArithmeticException
            int zahl1 = 10;
            int zahl2 = 0;
            int ergebnis = zahl1 / zahl2;  // Fehler tritt hier auf

            System.out.println("Ergebnis: " + ergebnis);
        } catch (ArithmeticException e) {
            // Fehlerbehandlung: Nachricht ausgeben, Programm läuft weiter
            System.out.println("Fehler: Division durch Null ist nicht erlaubt.");
            System.out.println("Details: " + e.getMessage());
        } finally {
            // Dieser Block wird immer ausgeführt, egal ob Fehler auftritt oder nicht
            System.out.println("Dieser Code läuft immer, z. B. zum Aufräumen.");
        }

        System.out.println("Programm läuft weiter...");
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="datverarb">Dateiverarbeitung</h1>
        <p>
            Die <strong>Dateiverarbeitung</strong> erlaubt es dir, Dateien zu lesen und zu schreiben – etwa um Konfigurationen zu speichern, Logs anzulegen oder Nutzerdaten zu verwalten. 
            Java stellt dafür Klassen wie <code>FileReader</code>, <code>BufferedReader</code>, <code>FileWriter</code> oder <code>Files</code> aus dem <code>java.io</code>- bzw. <code>java.nio.file</code>-Paket zur Verfügung. 
            Eine sichere Dateiverarbeitung nutzt <code>try-with-resources</code> oder <code>finally</code>, um geöffnete Dateien zuverlässig zu schliessen. 
            So schreibst du Programme, die Daten dauerhaft speichern und später wiederverwenden können.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Datei schreiben</h3>
        <pre class="language-java"><code>
import java.io.FileWriter;
import java.io.IOException;

public class DateiSchreiber {

    public static void main(String[] args) {
        try (FileWriter writer = new FileWriter("output.txt")) {
            writer.write("Hallo Welt!\n");
            writer.write("Dies ist eine Datei mit Java geschrieben.\n");
            writer.write("Dateiverarbeitung ist nützlich.");
            System.out.println("Datei erfolgreich geschrieben.");
        } catch (IOException e) {
            System.out.println("Fehler beim Schreiben der Datei: " + e.getMessage());
        }
    }
}
        </code></pre>
        <h3>Datei lesen</h3>
        <pre class="language-java"><code>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class DateiLeser {

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("output.txt"))) {
            String zeile;
            while ((zeile = reader.readLine()) != null) {
                System.out.println(zeile);
            }
        } catch (IOException e) {
            System.out.println("Fehler beim Lesen der Datei: " + e.getMessage());
        }
    }
}
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="collframe">Collections Framework</h1>
        <p>
            Das <strong>Java Collections Framework</strong> ist eine Sammlung vordefinierter Klassen und Interfaces, die dir das Arbeiten mit Gruppen von Objekten erleichtert. 
            Es bietet Datenstrukturen wie <code>List</code>, <code>Set</code>, <code>Map</code> und viele mehr. 
            Mit diesen Strukturen kannst du z. B. Daten speichern, sortieren, durchsuchen und bearbeiten – ohne selbst komplexe Algorithmen schreiben zu müssen. 
            Listen erlauben geordnete Elemente mit Duplikaten, Sets speichern nur eindeutige Werte, und Maps verknüpfen Schlüssel mit Werten. 
            Durch die gemeinsame Architektur mit Interfaces wie <code>Collection</code> oder <code>Iterable</code> ist der Umgang mit den Strukturen einheitlich und flexibel.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import java.util.*;

public class CollectionsBeispiel {
    public static void main(String[] args) {

        // --- List: geordnete Sammlung mit Duplikaten ---
        List&lt;String&gt; einkaufsliste = new ArrayList&lt;>();
        einkaufsliste.add("Milch");
        einkaufsliste.add("Brot");
        einkaufsliste.add("Milch");  // Duplikat erlaubt

        System.out.println("Einkaufsliste (List): " + einkaufsliste);

        // --- Set: ungeordnete Sammlung ohne Duplikate ---
        Set&lt;String&gt; farben = new HashSet&lt;>();
        farben.add("Blau");
        farben.add("Grün");
        farben.add("Blau");  // Wird ignoriert

        System.out.println("Farben (Set): " + farben);

        // --- Map: Schlüssel-Wert-Paare ---
        Map&lt;String, Integer&gt; punkte = new HashMap&lt;>();
        punkte.put("Anna", 95);
        punkte.put("Ben", 88);
        punkte.put("Anna", 97);  // Überschreibt vorherigen Wert

        System.out.println("Punkte (Map): " + punkte);

        // Zugriff auf einzelne Einträge:
        System.out.println("Punkte von Anna: " + punkte.get("Anna"));

        // Iteration durch die Map:
        System.out.println("Alle Einträge:");
        for (Map.Entry&lt;String, Integer&gt; eintrag : punkte.entrySet()) {
            System.out.println(eintrag.getKey() + " → " + eintrag.getValue());
        }
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Generics">Generics</h1>
        <p>
            <strong>Generics</strong> ermöglichen es dir, Klassen, Interfaces und Methoden so zu definieren, dass sie mit verschiedenen Datentypen arbeiten können – ohne auf Typsicherheit zu verzichten. 
            Anstatt für jeden Typ eine eigene Klasse zu schreiben, kannst du mit einem Typparameter <code>&lt;T&gt;</code> flexibel und wiederverwendbar programmieren. 
            Der Compiler prüft dabei zur Übersetzungszeit, ob der verwendete Typ korrekt ist – so vermeidest du Laufzeitfehler und musst keine umständlichen Typumwandlungen machen. 
            Generics werden besonders häufig mit Sammlungen wie <code>List&lt;String&gt;</code> oder <code>Map&lt;String, Integer&gt;</code> verwendet.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
// Eine generische Klasse, die ein beliebiges Objekt speichert
class Box&lt;T&gt; {
    private T inhalt;

    public void set(T wert) {
        inhalt = wert;
    }

    public T get() {
        return inhalt;
    }
}

// Eine generische Methode, die ein Array beliebigen Typs durchläuft
class Util {
    public static &lt;T&gt; void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}

public class GenericsDemo {
    public static void main(String[] args) {
        // Beispiel mit generischer Klasse Box
        Box&lt;String&gt; stringBox = new Box&lt;>();
        stringBox.set("Hallo Generics!");
        System.out.println("Inhalt der Box: " + stringBox.get());

        Box&lt;Integer&gt; zahlenBox = new Box&lt;>();
        zahlenBox.set(42);
        System.out.println("Inhalt der ZahlenBox: " + zahlenBox.get());

        // Beispiel mit generischer Methode
        String[] namen = {"Anna", "Ben", "Clara"};
        Integer[] zahlen = {1, 2, 3};

        System.out.println("\nString-Array:");
        Util.printArray(namen);

        System.out.println("\nInteger-Array:");
        Util.printArray(zahlen);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Lambda-Ausdrücke">Lambda-Ausdrücke</h1>
        <p>
            <strong>Lambda-Ausdrücke</strong> wurden mit Java 8 eingeführt und ermöglichen es dir, Funktionen als Argumente zu übergeben – ganz im Stil der funktionalen Programmierung. 
            Statt anonyme Klassen für Interfaces mit nur einer Methode (sogenannte „<em>funktionale Interfaces</em>“) zu schreiben, kannst du mit einem Lambda-Ausdruck den Code deutlich kürzer und lesbarer gestalten. 
            Die Syntax ist einfach: <code>(Parameter) -&gt; Ausdruck</code> oder <code>(Parameter) -&gt; { Codeblock }</code>. 
            Besonders häufig nutzt man Lambdas in Kombination mit Streams oder bei Event-Handling in GUI-Anwendungen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import java.util.*;

public class LambdaBeispiel {
    public static void main(String[] args) {
        List<String> namen = Arrays.asList("Anna", "Ben", "Clara", "David");

        // Ausgabe der Liste mit Lambda in forEach
        System.out.println("Alle Namen:");
        namen.forEach(name -> System.out.println("• " + name));

        // Liste alphabetisch sortieren (kein Lambda nötig – Standard)
        Collections.sort(namen);
        System.out.println("\nAlphabetisch sortiert: " + namen);

        // Liste nach Länge der Namen sortieren – mit Lambda-Ausdruck
        namen.sort((a, b) -> Integer.compare(a.length(), b.length()));
        System.out.println("\nSortiert nach Länge: " + namen);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="streamapi">Streams API</h1>
        <p>
            Die <strong>Streams API</strong> ermöglicht eine moderne, deklarative Art der Datenverarbeitung – ähnlich wie bei Pipelines in funktionalen Sprachen. 
            Statt klassische Schleifen zu schreiben, kannst du mit <code>Streams</code> Daten elegant filtern, sortieren, umwandeln und aggregieren. 
            Streams verarbeiten Daten sequenziell oder parallel, und nutzen dabei Operationen wie <code>filter()</code>, <code>map()</code>, <code>sorted()</code> oder <code>collect()</code>. 
            Die Verarbeitung erfolgt in mehreren Stufen: Erzeugung eines Streams, Transformation der Daten und schliesslich eine Terminal-Operation wie <code>forEach()</code> oder <code>collect()</code>. 
            Das macht den Code nicht nur kompakter, sondern oft auch besser lesbar.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import java.util.*;
import java.util.stream.Collectors;

public class StreamsBeispiel {
    public static void main(String[] args) {
        List&lt;String&gt; namen = Arrays.asList("Anna", "Ben", "Clara", "David", "Amir");

        // Alle Namen mit A, in Grossbuchstaben, alphabetisch sortiert
        List&lt;String&gt; gefilterteListe = namen.stream()
            .filter(name -> name.startsWith("A"))      // nur Namen mit A
            .map(String::toUpperCase)                  // zu Grossbuchstaben umwandeln
            .sorted()                                  // alphabetisch sortieren
            .collect(Collectors.toList());             // als neue Liste zurückgeben

        System.out.println("Gefilterte & verarbeitete Namen: " + gefilterteListe);

        // Namen direkt ausgeben, deren Länge > 4 ist
        System.out.println("\nNamen mit mehr als 4 Buchstaben:");
        namen.stream()
            .filter(name -> name.length() > 4)
            .forEach(System.out::println);
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Multithreading">Multithreading</h1>
        <p>
            <strong>Multithreading</strong> ermöglicht es Java-Programmen, mehrere Aufgaben gleichzeitig (parallel) auszuführen. 
            Jeder „<em>Thread</em>“ ist ein unabhängiger Ausführungspfad, der neben anderen Threads läuft. Das ist besonders nützlich für rechenintensive Prozesse, lange Wartezeiten (z. B. bei Netzwerk- oder Dateizugriffen) oder für Anwendungen mit Benutzeroberflächen, bei denen das Hauptprogramm nicht blockiert werden soll. 
            In Java kannst du Threads entweder durch Vererbung von <code>Thread</code> oder durch Implementierung des <code>Runnable</code>-Interfaces erstellen. 
            Threads werden mit <code>.start()</code> gestartet und laufen unabhängig vom Hauptprogramm weiter. Beachte: Bei paralleler Ausführung können Race Conditions auftreten – sichere Zugriffe müssen mit Synchronisation geschützt werden.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
// Variante 1: Thread-Klasse erweitern
class MeinThread extends Thread {
    private String name;

    public MeinThread(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 1; i &lt;= 5; i++) {
            System.out.println(name + " zählt: " + i);
            try {
                Thread.sleep(500); // 500 Millisekunden Pause
            } catch (InterruptedException e) {
                System.out.println(name + " wurde unterbrochen.");
            }
        }
    }
}

// Variante 2: Runnable-Interface verwenden
class MeinRunnable implements Runnable {
    private String name;

    public MeinRunnable(String name) {
        this.name = name;
    }

    public void run() {
        for (int i = 1; i &lt;= 5; i++) {
            System.out.println(name + " zählt: " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println(name + " wurde unterbrochen.");
            }
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        // Variante 1 starten
        MeinThread t1 = new MeinThread("Thread-1");
        t1.start();

        // Variante 2 starten
        Thread t2 = new Thread(new MeinRunnable("Thread-2"));
        t2.start();

        // Hauptthread
        System.out.println("→ Hauptprogramm läuft weiter …");
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="jdbcon">Java Database Connectivity</h1>
        <p>
            <strong>JDBC (Java Database Connectivity)</strong> ist das Standard-API von Java, um mit relationalen Datenbanken wie MySQL, PostgreSQL oder SQLite zu kommunizieren. 
            Es erlaubt dir, SQL-Befehle auszuführen, Daten abzufragen und zu bearbeiten – alles direkt aus deinem Java-Code. 
            Über einen JDBC-Treiber verbindet sich dein Programm mit der Datenbank, erstellt Verbindungen, führt Statements aus und verarbeitet Ergebnisse.
            Typische Schritte sind: <code>Treiber laden</code>, <code>Datenbankverbindung aufbauen</code>, <code>SQL-Statement ausführen</code>, <code>Ergebnisse verarbeiten</code> und <code>Verbindung schliessen</code>.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import java.sql.*;

public class JdbcBeispiel {
    public static void main(String[] args) {
        Connection verbindung = null;
        Statement statement = null;
        ResultSet ergebnisse = null;

        try {
            // 1. Verbindung zur SQLite-Datenbank aufbauen (Datei "beispiel.db")
            verbindung = DriverManager.getConnection("jdbc:sqlite:beispiel.db");

            // 2. Statement erzeugen
            statement = verbindung.createStatement();

            // 3. SQL-Tabelle erstellen, falls nicht vorhanden
            String createSQL = "CREATE TABLE IF NOT EXISTS personen (" +
                               "id INTEGER PRIMARY KEY, " +
                               "name TEXT, " +
                               "alter INTEGER)";
            statement.execute(createSQL);

            // 4. Beispiel-Daten einfügen
            String insertSQL = "INSERT INTO personen (name, alter) VALUES ('Anna', 25), ('Ben', 30)";
            statement.execute(insertSQL);

            // 5. Daten auslesen
            ergebnisse = statement.executeQuery("SELECT * FROM personen");

            // 6. Ergebnisse anzeigen
            System.out.println("Personen in der Datenbank:");
            while (ergebnisse.next()) {
                int id = ergebnisse.getInt("id");
                String name = ergebnisse.getString("name");
                int alter = ergebnisse.getInt("alter");
                System.out.println(id + ": " + name + " (" + alter + " Jahre)");
            }

        } catch (SQLException e) {
            System.err.println("Datenbankfehler: " + e.getMessage());
        } finally {
            // 7. Ressourcen schliessen
            try {
                if (ergebnisse != null) ergebnisse.close();
                if (statement != null) statement.close();
                if (verbindung != null) verbindung.close();
            } catch (SQLException e) {
                System.err.println("Fehler beim Schliessen: " + e.getMessage());
            }
        }
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="junite">JUnit Testing</h1>
        <p>
            <strong>JUnit</strong> ist das Standard-Framework für das Testen von Java-Anwendungen. 
            Es hilft dir, automatisierte Tests für Methoden zu schreiben, um sicherzustellen, dass dein Code korrekt funktioniert und bei Änderungen stabil bleibt. 
            JUnit basiert auf sogenannten „Testfällen“, die Methoden aus deiner Anwendung gezielt prüfen. 
            Mit <code>@Test</code> markierst du eine Methode als Test, und mit <code>Assertions</code> (z. B. <code>assertEquals</code>, <code>assertTrue</code>) überprüfst du die erwarteten Ergebnisse. 
            JUnit-Tests laufen automatisiert und sind essenziell für moderne Softwareentwicklung – insbesondere bei TDD (Test-Driven Development) und CI/CD-Prozessen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Klasse für den Test</h3>
        <pre class="language-java"><code>
// Datei: Rechner.java
public class Rechner {
    public int addiere(int a, int b) {
        return a + b;
    }

    public int dividiere(int a, int b) {
        if (b == 0) throw new IllegalArgumentException("Division durch Null!");
        return a / b;
    }
}
        </code></pre>  
        <br>
        <h3>JUnit Testklasse</h3>
        <pre class="language-java"><code>
// Datei: RechnerTest.java

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class RechnerTest {

    @Test
    void testAddition() {
        Rechner rechner = new Rechner();
        int ergebnis = rechner.addiere(3, 4);
        assertEquals(7, ergebnis, "3 + 4 sollte 7 ergeben");
    }

    @Test
    void testDivision() {
        Rechner rechner = new Rechner();
        int ergebnis = rechner.dividiere(10, 2);
        assertEquals(5, ergebnis, "10 / 2 sollte 5 ergeben");
    }

    @Test
    void testDivisionDurchNull() {
        Rechner rechner = new Rechner();
        assertThrows(IllegalArgumentException.class, () -> {
            rechner.dividiere(10, 0);
        }, "Division durch 0 sollte eine Exception werfen");
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="JavaFX">JavaFX</h1>
        <p>
            <strong>JavaFX</strong> ist ein modernes Framework zur Erstellung grafischer Benutzeroberflächen (GUIs) in Java. 
            Es ist der offizielle Nachfolger von Swing und bietet eine klare Struktur, CSS-Styling, FXML-Unterstützung und sogar 2D/3D-Grafikfähigkeiten. 
            JavaFX basiert auf einer komponentenbasierten Architektur: Du erstellst eine <code>Stage</code> (Fenster), platzierst darin eine <code>Scene</code> und fügst grafische Elemente wie Buttons, Labels und Layouts hinzu. 
            Es eignet sich ideal für Desktop-Anwendungen, Tools und visuelle Java-Projekte.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class JavaFxBeispiel extends Application {

    @Override
    public void start(Stage primaryStage) {
        // Erstellen eines Buttons mit Text
        Button button = new Button("Klick mich!");

        // Ereignis (Event) hinzufügen – bei Klick wird Text geändert
        button.setOnAction(e -> button.setText("Hallo JavaFX!"));

        // Layout-Container erstellen und Button hinzufügen
        StackPane root = new StackPane();
        root.getChildren().add(button);

        // Szene mit Layout erstellen (300x200 Pixel)
        Scene scene = new Scene(root, 300, 200);

        // Fenster konfigurieren
        primaryStage.setTitle("Mein erstes JavaFX-Fenster");
        primaryStage.setScene(scene);
        primaryStage.show(); // Fenster anzeigen
    }

    public static void main(String[] args) {
        launch(args); // Startet JavaFX-Anwendung
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="JSP">Servlets und JSP</h1>
        <p>
            <strong>Servlets</strong> und <strong>JSP</strong> sind klassische Java-Technologien zur Entwicklung dynamischer Webanwendungen. 
            Ein <code>Servlet</code> ist eine Java-Klasse, die HTTP-Anfragen verarbeitet (z. B. Formulare) und HTML-Antworten erzeugt. 
            <code>JSP</code> hingegen erlaubt dir, Java-Code direkt in HTML-Seiten einzubetten – ideal zur Darstellung dynamischer Inhalte. 
            Während Servlets eher für Logik zuständig sind, übernimmt JSP die Präsentation. 
            Beide Technologien laufen auf einem Java-Webserver wie Apache Tomcat.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>Servelet</h3>
        <pre class="language-java"><code>
// Datei: HalloServlet.java

import java.io.*;
import jakarta.servlet.*;
import jakarta.servlet.http.*;

public class HalloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // Daten an JSP übergeben
        request.setAttribute("benutzername", "Nathan");

        // Weiterleiten an JSP-Seite
        RequestDispatcher dispatcher = request.getRequestDispatcher("hallo.jsp");
        dispatcher.forward(request, response);
    }
}
        </code></pre>
        <br>
        <h3>JSP-Seite</h3>
        <pre><code>
&lt;!-- Datei: hallo.jsp --&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&lt;
    &lt;title>Begrüssung&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Willkommen, &lt;%= request.getAttribute("benutzername") %&gt;!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Spring">Spring Framework</h1>
        <p>
            <strong>Spring Framework</strong> ist eines der beliebtesten Java-Frameworks für die Entwicklung von Enterprise-Anwendungen. 
            Es bietet eine umfangreiche Infrastruktur zur einfachen Erstellung von flexiblen, modularen und wartbaren Anwendungen. 
            Spring basiert auf dem Prinzip der <em>Inversion of Control (IoC)</em> und der <em>Dependency Injection (DI)</em>, wodurch Komponenten locker gekoppelt werden. 
            Es unterstützt u.a. Webentwicklung (Spring MVC), Datenbankzugriff (Spring Data), Sicherheit (Spring Security) und vieles mehr. 
            Mit Spring kannst du komplexe Anwendungen strukturieren, wiederverwendbaren Code schreiben und dank integrierter Test-Unterstützung robust entwickeln.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-java"><code>
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

// Hauptklasse für die Spring Boot Anwendung
@SpringBootApplication
public class MeineSpringApp {
    public static void main(String[] args) {
        SpringApplication.run(MeineSpringApp.class, args);
    }
}

// REST-Controller, der HTTP GET-Anfragen beantwortet
@RestController
class HalloController {

    // Pfad: /hallo
    @GetMapping("/hallo")
    public String sagHallo() {
        return "Hallo vom Spring Framework!";
    }
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Maven">Maven</h1>
        <p>
            <strong>Maven</strong> ist ein weit verbreitetes Build- und Projektmanagement-Tool für Java-Anwendungen. 
            Es automatisiert den Bauprozess, verwaltet Abhängigkeiten (Bibliotheken) und unterstützt die Organisation von Projekten nach einem standardisierten Modell. 
            Mit Maven kannst du schnell externe Bibliotheken herunterladen, deine Anwendung kompilieren, Tests ausführen und fertige Pakete (JAR, WAR) erzeugen – alles über einfache Befehle. 
            Ausserdem sorgt Maven für einheitliche Projektstrukturen, was Zusammenarbeit im Team erleichtert.
        </p>
        <h2>Beispiel</h2>
        <pre><code>
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.meinefirma&lt;/groupId&gt;
  &lt;artifactId&gt;mein-projekt&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;

  &lt;properties&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;!-- Beispiel: JUnit für Tests --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
      &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
      &lt;version&gt;5.10.0&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Beispiel: Spring Boot Starter Web --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
      &lt;version&gt;3.1.3&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;!-- Compiler Plugin für Java 17 --&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.11.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;17&lt;/source&gt;
          &lt;target&gt;17&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;
        </code></pre>
    </main>

    <script>
        function scrollNav(amount) {
            document.getElementById('navWrapper').scrollBy({ left: amount, behavior: 'smooth' });
        }
    </script>
</body>
</html>