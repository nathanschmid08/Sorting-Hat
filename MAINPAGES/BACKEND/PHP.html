<!DOCTYPE html>
<html lang = "de">
<head>
    <title>PHP</title>
    <meta charset = "UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary-color: #787BAF;
            --hover-color: #8f94da;
            --bg-primary: #1e1e1e;
            --bg-secondary: #141414;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2d2d2d;
        }

        html, body {
            background-color: #1e1e1e !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Dela Gothic One', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        header {
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            padding: 3rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        header img {
            height: 80px;
            width: 80px;
            object-fit: contain;
            border-radius: 12px;
        }

        header h1 {
            font-size: 3rem;
            color: var(--text-primary);
            font-weight: normal;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sticky-nav-container {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
        }

        .nav-scroll-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            padding: 0 1rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .nav-scroll-btn:hover {
            color: var(--primary-color);
        }

        .nav-wrapper {
            overflow-x: auto;
            white-space: nowrap;
            flex: 1;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .nav-wrapper::-webkit-scrollbar {
            display: none;
        }

        nav ul {
            display: inline-flex;
            list-style: none;
            gap: 1rem;
            padding: 0 1rem;
        }

        nav a {
            text-decoration: none;
            color: var(--text-primary);
            font-size: 0.85rem;
            padding: 0.4rem 0.75rem;
            border-radius: 0.25rem;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        nav a:hover {
            color: var(--primary-color);
        }

        main {
            padding: 2rem;
        }

        main h1 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        main h2 {
            margin-top: 2rem;
            font-size: 1.5rem;
            color: var(--hover-color);
        }

        main p {
            font-family: 'Source Sans 3', sans-serif;
            margin-top: 1rem;
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        main a {
            color: #ffff;
            text-decoration: none;
        }

        .hljs,
        .hljs * {
            background: none !important;
        }

        pre {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            margin-top: 1rem;
        }

        code {
            font-family: monospace;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <header>
        <img src="LOGO/php.png" alt="">
        <h1>PHP</h1>
    </header>
    <div class="sticky-nav-container">
        <button class="nav-scroll-btn" onclick="scrollNav(-200)">&#x25C0;</button>
        <div class="nav-wrapper" id="navWrapper">
            <nav>
                <ul>
                    <li><a href="#intro">Einführung</a></li>
                    <li><a href="#installation">Installation und Einrichtung</a></li>
                    <li><a href="#syntax">Grundlegende Syntax</a></li>
                    <li><a href="#vardat">Variablen und Datentypen</a></li>
                    <li><a href="#Operatoren">Operatoren</a></li>
                    <li><a href="#Kontrollstrukturen">Kontrollstrukturen</a></li>
                    <li><a href="#Funktionen">Funktionen</a></li>
                    <li><a href="#Arrays">Arrays</a></li>
                    <li><a href="#assoarray">Assoziative Arrays</a></li>
                    <li><a href="#supglobarray">Superglobale Arrays</a></li>
                    <li><a href="#Formularverarbeitung">Formularverarbeitung</a></li>
                    <li><a href="#sessioncookie">Session und Cookies</a></li>
                    <li><a href="#Dateiverarbeitung">Dateiverarbeitung</a></li>
                    <li><a href="#Fehlerbehandlung">Fehlerbehandlung</a></li>
                    <li><a href="#classobjs">Klassen und Objekte</a></li>
                    <li><a href="#oop">Einführung in OOP</a></li>
                    <li><a href="#Vererbung">Vererbung</a></li>
                    <li><a href="#Polymorphismus">Polymorphismus</a></li>
                    <li><a href="#abstrclass">Abstrakte Klassen</a></li>
                    <li><a href="#Interfaces">Interfaces</a></li>
                    <li><a href="#dataobjs">PHP Data Objects</a></li>
                    <li><a href="#MySQL">MySQL</a></li>
                    <li><a href="#prepstat">Prepared Statements</a></li>
                    <li><a href="#crud">CRUD Operationen</a></li>
                    <li><a href="#file">File Uploads</a></li>
                    <li><a href="#Mailversand">Mailversand</a></li>
                    <li><a href="#json">JSON Verarbeitung</a></li>
                    <li><a href="#restapi">RESTful APIs</a></li>
                    <li><a href="#Composer">Composer</a></li>
                    <li><a href="#ut">Unit Testing</a></li>
                </ul>
            </nav>
        </div>
        <button class="nav-scroll-btn" onclick="scrollNav(200)">&#x25B6;</button>
    </div>

    <main>
        <h1 class="intro">Einführung</h1>
        <p>PHP (Hypertext Preprocessor) ist eine serverseitige Programmiersprache, die speziell für die Webentwicklung entwickelt wurde. 
            Anders als JavaScript, das im Browser läuft, wird PHP auf dem Server ausgeführt und erzeugt dynamische Webseiteninhalte, bevor sie an den Browser gesendet werden. 
            PHP ermöglicht es dir, Datenbanken anzusprechen, Formulare zu verarbeiten oder benutzerdefinierte Inhalte je nach Nutzer zu erstellen. 
            Es ist sehr beliebt und weit verbreitet, vor allem für die Entwicklung von Content-Management-Systemen wie WordPress. 
            Obwohl es schon lange existiert, wird PHP ständig weiterentwickelt und bleibt ein wichtiger Baustein im modernen Web.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-html"><code>
&lt;!DOCTYPE html&gt;
&lt;html lang="de"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;PHP-Mix&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;?php
        echo "&lt;p&gt;Das ist ein PHP-Abschnitt.&lt;/p&gt;";
    ?&gt;
    &lt;p&gt;Das ist reines HTML.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="installation">Installation und Einrichtung</h1>
        <p>
            Um mit PHP programmieren zu können, musst du zuerst den <strong>PHP-Interpreter</strong> auf deinem Rechner installieren.
            Er ermöglicht das Ausführen von PHP-Skripten und ist die Grundlage für die Entwicklung von Webanwendungen.
        </p>
  
        <h2>1. PHP herunterladen</h2>
        <p>
            Die einfachste Möglichkeit ist der Download von der offiziellen <a href="https://www.php.net/downloads" target="_blank">PHP-Webseite</a>.
            Dort findest du Versionen für verschiedene Betriebssysteme (Windows, macOS, Linux).
            Für Einsteiger ist es empfehlenswert, die aktuelle stabile Version zu verwenden.
        </p>
  
        <h2>2. PHP installieren</h2>
        <p>
            Nach dem Download kannst du PHP je nach Betriebssystem folgendermassen installieren:
        </p>
        <p>
            <strong>Windows:</strong> Lade die <em>Thread Safe</em>-Version herunter und entpacke sie an einen Ort deiner Wahl. 
            Füge dann den Pfad zum PHP-Ordner in die Systemumgebungsvariablen (PATH) hinzu, damit du PHP im Terminal nutzen kannst.
        </p>
        <p>
            <strong>macOS (mit Homebrew):</strong> Öffne das Terminal und gib ein:
        </p>

        <br>

        <pre class="language-bash"><code>
brew install php
        </code></pre>

        <p><strong>Linux (z. B. Ubuntu):</strong> Öffne ein Terminal und gib folgenden Befehl ein:</p>

        <br>

        <pre class="language-bash"><code>
sudo apt update
sudo apt install php
        </code></pre>
    
  
        <h2>3. Installation überprüfen</h2>
        <p>
            Öffne ein Terminal oder die Eingabeaufforderung und gib folgendes ein:<br>
            <code>php -v</code><br>
            Wenn du eine Ausgabe mit der PHP-Version wie <code>PHP 8.x.x</code> siehst, ist PHP korrekt installiert.
        </p>
  
        <h2>Welche IDE ist empfehlenswert?</h2>
        <p>
            Für PHP eignet sich besonders <strong>Visual Studio Code</strong> mit der Erweiterung <em>PHP Intelephense</em>. 
            VS Code ist kostenlos, leichtgewichtig und bietet viele nützliche Features wie Syntax-Highlighting, Autovervollständigung und Debugging.
            Du kannst es hier herunterladen: <a href="https://code.visualstudio.com/" target="_blank">VS Code Download</a>.
        </p>
        
        <p>
            Alternativ sind auch <strong>PHPStorm</strong> (kostenpflichtig, sehr umfangreich) oder <strong>NetBeans</strong> gute Optionen für professionelle PHP-Entwicklung.
        </p>
  
        <h2>Erstes PHP-Programm</h2>
        <p>
            Erstelle eine Datei mit dem Namen <code>index.php</code> und schreibe folgenden Code hinein:
        </p>
        <pre><code class="language-php">
&lt;?php
    echo "Hallo, PHP!";
?&gt;
        </code></pre>
        <p>
            Öffne das Terminal, navigiere zum Ordner mit der Datei und starte das Skript mit:<br>
            <code>php index.php</code><br>
            Schon wird dein erstes PHP-Programm die Ausgabe <em>Hallo, PHP!</em> anzeigen.
        </p>

        <br>
        <br>
        <br>

        <h1 id="syntax">Grundlegende Syntax</h1>
        <p>
            Die grundlegende Syntax von PHP ist relativ einfach und ähnelt vielen anderen Programmiersprachen, insbesondere C, JavaScript oder Perl. 
            PHP-Code wird immer innerhalb spezieller PHP-Tags geschrieben, die dem Webserver signalisieren, dass der enthaltene Code ausgeführt werden muss. 
            Dabei kannst du Variablen deklarieren, Kontrollstrukturen nutzen, Funktionen definieren und mit Daten arbeiten. 
            Kommentare helfen dir dabei, den Code verständlich zu dokumentieren.
        </p>
        <p>
            Ein PHP-Skript kann direkt in eine HTML-Datei eingebettet werden oder als eigenständige PHP-Datei vorliegen. 
            Standardmässig endet jede PHP-Anweisung mit einem Semikolon <code>;</code>. 
            Variablennamen beginnen immer mit einem <code>$</code>-Zeichen, gefolgt von Buchstaben, Zahlen oder Unterstrichen. 
            PHP ist typfrei, das bedeutet, dass Variablen keine expliziten Datentypen benötigen – der Typ wird dynamisch zur Laufzeit festgelegt.
        </p>
        <p>
            Die Ausführung eines PHP-Skripts beginnt immer am Anfang und läuft sequenziell ab. 
            Mit Kontrollstrukturen wie <code>if</code>, <code>else</code>, <code>for</code> oder <code>while</code> kannst du den Ablauf beeinflussen. 
            Funktionen helfen dir, wiederkehrende Aufgaben zu kapseln und deinen Code sauberer und modularer zu gestalten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// PHP-Tags öffnen und schliessen den PHP-Codeblock

// 1. Variablen deklarieren und Werte zuweisen
$name = "Anna";             // String
$alter = 25;                // Integer
$pi = 3.14159;              // Float (Dezimalzahl)
$istStudent = true;         // Boolean (wahr/falsch)

// 2. Kommentare
// Einzeiliger Kommentar

/*
   Mehrzeiliger
   Kommentar
*/

// 3. Ausgabe mit echo
echo "Hallo, mein Name ist $name.&lt;br&gt;";  // Variablen werden in Strings ersetzt
echo "Ich bin $alter Jahre alt.&lt;br&gt;";

// 4. Kontrollstruktur if-else
if ($alter >= 18) {
    echo "Du bist volljährig.&lt;br&gt;";
} else {
    echo "Du bist minderjährig.&lt;br&gt;";
}

// 5. Schleife (for)
echo "Zahlen von 1 bis 5:&lt;br&gt;";
for ($i = 1; $i &lt;= 5; $i++) {
    echo $i . " ";
}
echo "&lt;br&gt;";

// 6. Funktion definieren und aufrufen
function begruessung($name) {
    return "Hallo, " . $name . "! Willkommen auf der Website.&lt;br&gt;";
}

echo begruessung($name);

// 7. Arrays - Sammlung von Werten
$farben = ["Rot", "Grün", "Blau"];
echo "Meine Lieblingsfarbe ist " . $farben[1] . ".&lt;br&gt;";

// 8. foreach-Schleife für Arrays
echo "Alle Farben: ";
foreach ($farben as $farbe) {
    echo $farbe . " ";
}
echo "&lt;br&gt;";

// 9. Assoziatives Array (key => value)
$person = [
    "Name" => "Max",
    "Alter" => 30,
    "Beruf" => "Entwickler"
];

echo $person["Name"] . " arbeitet als " . $person["Beruf"] . ".&lt;br&gt;";

// 10. Superglobale Variablen (z.B. $_GET, $_POST) können für Webformulare genutzt werden
// Beispiel: echo $_GET['param'];

// 11. Typkonvertierung (Casting)
$zahl = "123";    // String
$zahlInt = (int)$zahl;  // jetzt Integer

echo "Der Wert ist jetzt vom Typ: " . gettype($zahlInt) . ".&lt;br&gt;";

// 12. Fehlerbehandlung mit try-catch (ab PHP 5)
try {
    // Beispiel: Division durch Null vermeiden
    $divisor = 0;
    if ($divisor == 0) {
        throw new Exception("Division durch Null ist nicht erlaubt!");
    }
    $ergebnis = 10 / $divisor;
} catch (Exception $e) {
    echo "Fehler: " . $e->getMessage() . "&lt;br&gt;";
}

?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="vardat">Variablen und Datentypen</h1>
        <p>
            In PHP beginnen alle Variablen mit einem Dollarzeichen <code>$</code>, gefolgt vom Namen der Variablen. 
            PHP ist eine dynamisch typisierte Sprache, was bedeutet, dass du keinen Datentyp angeben musst – PHP erkennt den Typ automatisch anhand des zugewiesenen Werts. 
            Es gibt mehrere grundlegende Datentypen, darunter <strong>Strings</strong> (Texte), <strong>Integers</strong> (Ganzzahlen), <strong>Floats</strong> (Gleitkommazahlen), 
            <strong>Booleans</strong> (wahr/falsch), <strong>Arrays</strong>, <strong>Objects</strong> und <strong>null</strong> (kein Wert).
        </p>
        <p>
            Du kannst Variablen einfach deklarieren, indem du sie mit einem Wert belegst, z.&nbsp;B. <code>$name = "Max";</code>. 
            Mit der Funktion <code>gettype()</code> kannst du herausfinden, welchen Typ eine Variable aktuell hat. 
            PHP ist flexibel und erlaubt es dir sogar, den Datentyp einer Variable später durch neue Zuweisung zu ändern.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// String – Zeichenkette
$name = "Anna";
echo "Name: $name&lt;br&gt;";
echo "Typ: " . gettype($name) . "&lt;br&gt;&lt;br&gt;";

// Integer – Ganzzahl
$alter = 25;
echo "Alter: $alter&lt;br&gt;";
echo "Typ: " . gettype($alter) . "&lt;br&gt;&lt;br&gt;";

// Float – Kommazahl
$pi = 3.14159;
echo "Pi: $pi&lt;br&gt;";
echo "Typ: " . gettype($pi) . "&lt;br&gt;&lt;br&gt;";

// Boolean – Wahrheitswert
$istStudent = true;
echo "Ist Student? " . ($istStudent ? "Ja" : "Nein") . "&lt;br&gt;";
echo "Typ: " . gettype($istStudent) . "&lt;br&gt;&lt;br&gt;";

// Array – Liste von Werten
$farben = ["Rot", "Grün", "Blau"];
echo "Zweite Farbe im Array: " . $farben[1] . "&lt;br&gt;";
echo "Typ: " . gettype($farben) . "&lt;br&gt;&lt;br&gt;";

// NULL – Keine Zuweisung
$nichtDefiniert = null;
echo "Variable mit null: ";
var_dump($nichtDefiniert);
echo "&lt;br&gt;Typ: " . gettype($nichtDefiniert) . "&lt;br&gt;&lt;br&gt;";

// Dynamische Typänderung
$wert = 100;            // Integer
$wert = "Hundert";      // Jetzt String
echo "Neuer Wert: $wert&lt;br&gt;";
echo "Neuer Typ: " . gettype($wert) . "&lt;br&gt;";
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="Operatoren">Operatoren</h1>
        <p>
            PHP bietet eine Vielzahl von Operatoren, mit denen du Werte vergleichen, berechnen, zuweisen oder logisch verknüpfen kannst. 
            Zu den wichtigsten Kategorien gehören <strong>arithmetische Operatoren</strong> wie <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, 
            <strong>Vergleichsoperatoren</strong> wie <code>==</code>, <code>===</code>, <code>!=</code>, <strong>logische Operatoren</strong> wie <code>&&</code> und <code>||</code>, 
            sowie <strong>Zuweisungsoperatoren</strong> wie <code>=</code> oder <code>+=</code>. 
            PHP kennt ausserdem den sogenannten <strong>Ternären Operator</strong> (<code>?:</code>) für einfache if-else-Ausdrücke in einer Zeile.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Arithmetische Operatoren
$a = 10;
$b = 3;

echo "Addition: $a + $b = " . ($a + $b) . "&lt;br&gt;";
echo "Subtraktion: $a - $b = " . ($a - $b) . "&lt;br&gt;";
echo "Multiplikation: $a * $b = " . ($a * $b) . "&lt;br&gt;";
echo "Division: $a / $b = " . ($a / $b) . "&lt;br&gt;";
echo "Modulus (Rest): $a % $b = " . ($a % $b) . "&lt;br&gt;&lt;br&gt;";

// Vergleichsoperatoren
echo "Gleich (==): ";
var_dump($a == $b); echo "&lt;br&gt;";

echo "Identisch (===): ";
var_dump($a === $b); echo "&lt;br&gt;";

echo "Ungleich (!=): ";
var_dump($a != $b); echo "&lt;br&gt;";

echo "Grösser als: ";
var_dump($a > $b); echo "&lt;br&gt;";

echo "Kleiner gleich: ";
var_dump($a &lt;= $b); echo "&lt;br&gt;&lt;br&gt;";

// Logische Operatoren
$istErwachsen = true;
$hatAusweis = false;

echo "Darf rein (UND): ";
var_dump($istErwachsen && $hatAusweis); echo "&lt;br&gt;";

echo "Darf rein (ODER): ";
var_dump($istErwachsen || $hatAusweis); echo "&lt;br&gt;&lt;br&gt;";

// Zuweisungsoperatoren
$x = 5;
$x += 3; // entspricht $x = $x + 3
echo "Ergebnis nach += 3: $x&lt;br&gt;";

$x *= 2; // entspricht $x = $x * 2
echo "Ergebnis nach *= 2: $x&lt;br&gt;&lt;br&gt;";

// Ternärer Operator
$alter = 20;
$status = ($alter >= 18) ? "Volljährig" : "Minderjährig";
echo "Status: $status&lt;br&gt;";
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Kontrollstrukturen">Kontrollstrukturen</h1>
        <p>
            Kontrollstrukturen ermöglichen es dir, den Programmfluss gezielt zu steuern – also zu entscheiden, ob bestimmte Codeabschnitte ausgeführt werden sollen oder nicht. 
            Die wichtigsten Kontrollstrukturen sind <code>if</code>, <code>else</code> und <code>elseif</code>, mit denen du Bedingungen prüfen und unterschiedliche Anweisungen ausführen kannst. 
            Für mehrere Fälle, die von einem einzigen Wert abhängen, eignet sich die <code>switch</code>-Anweisung besonders gut. 
            Zusätzlich gibt es Schleifen wie <code>while</code>, <code>do...while</code>, <code>for</code> und <code>foreach</code>, mit denen du Wiederholungen von Code ausführen kannst.
            Mit <code>break</code> kannst du Schleifen oder switch-Blöcke gezielt beenden, und mit <code>continue</code> springst du direkt zur nächsten Iteration einer Schleife.
            Diese Strukturen sind essenziell, um Programme dynamisch und interaktiv zu gestalten – z. B. um Benutzereingaben zu überprüfen, unterschiedliche Antworten zu geben oder Listen zu durchlaufen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Beispiel für if, else, elseif
$alter = 18;

if ($alter &lt; 13) {
    echo "Du bist ein Kind.&lt;br&gt;";
} elseif ($alter &lt; 18) {
    echo "Du bist ein Teenager.&lt;br&gt;";
} else {
    echo "Du bist erwachsen.&lt;br&gt;";
}

// Beispiel für switch
$wochentag = "Montag";

switch ($wochentag) {
    case "Montag":
        echo "Neue Woche, neues Glück!&lt;br&gt;";
        break;
    case "Freitag":
        echo "Fast Wochenende!&lt;br&gt;";
        break;
    default:
        echo "Ein ganz normaler Tag.&lt;br&gt;";
        break;
}

// Beispiel für Schleifen: for
echo "Zähle von 1 bis 5:&lt;br&gt;";
for ($i = 1; $i &lt;= 5; $i++) {
    echo $i . "&lt;br&gt;";
}

// Beispiel für Schleifen: foreach
$früchte = ["Apfel", "Banane", "Kirsche"];
echo "Meine Lieblingsfrüchte:&lt;br&gt;";
foreach ($früchte as $frucht) {
    echo "- $frucht&lt;br&gt;";
}

// Beispiel für continue und break
echo "Zähle bis 10, aber überspringe 5 und stoppe bei 8:&lt;br&gt;";
for ($i = 1; $i &lt;= 10; $i++) {
    if ($i == 5) {
        continue; // 5 wird übersprungen
    }
    if ($i == 9) {
        break; // Schleife endet vor 9
    }
    echo $i . "&lt;br&gt;";
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1>Funktionen</h1>
        <p>
            In PHP sind <strong>Funktionen</strong> wiederverwendbare Codeblöcke, die eine bestimmte Aufgabe ausführen. 
            Du kannst sie selbst definieren oder auf eine Vielzahl integrierter Funktionen zurückgreifen. 
            Eine Funktion wird mit dem Schlüsselwort <code>function</code> erstellt, gefolgt von einem Namen und optionalen Parametern in runden Klammern. 
            Innerhalb der geschweiften Klammern steht der auszuführende Code. 
            Funktionen können auch Werte zurückgeben – das geschieht mit <code>return</code>. 
            Durch Funktionen wird dein Code strukturierter, lesbarer und leichter wartbar. 
            Besonders nützlich sind sie, wenn du dieselbe Logik an mehreren Stellen brauchst – so musst du sie nicht immer wieder neu schreiben.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Eine einfache Funktion ohne Parameter
function begruessung() {
    echo "Willkommen auf meiner Website!&lt;br&gt;";
}

// Eine Funktion mit einem Parameter
function hallo($name) {
    echo "Hallo, $name!&lt;br&gt;";
}

// Eine Funktion mit mehreren Parametern und Rückgabewert
function addiere($a, $b) {
    return $a + $b;
}

// Funktion mit einem optionalen Parameter
function begruessungMitUhrzeit($name, $uhrzeit = "Tag") {
    echo "Guten $uhrzeit, $name!&lt;br&gt;";
}

// Funktionsaufrufe
begruessung();                              // Gibt: Willkommen auf meiner Website!

hallo("Nathan");                            // Gibt: Hallo, Nathan!

echo addiere(5, 3) . "&lt;br&gt;";                // Gibt: 8

begruessungMitUhrzeit("Lisa", "Morgen");    // Gibt: Guten Morgen, Lisa!

begruessungMitUhrzeit("Tom");               // Gibt: Guten Tag, Tom! (Standardwert)
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Arrays">Arrays</h1>
        <p>
            <strong>Arrays</strong> sind strukturierte Datentypen, mit denen du mehrere Werte unter einem gemeinsamen Namen speichern kannst. 
            Du kannst sowohl <em>indizierte Arrays</em> (mit numerischen Schlüsseln), <em>assoziative Arrays</em> (mit benutzerdefinierten Schlüsseln) als auch <em>mehrdimensionale Arrays</em> erstellen. 
            Arrays werden mit der Funktion <code>array()</code> oder der Kurzschreibweise <code>[]</code> definiert. 
            Sie eignen sich hervorragend zur Organisation zusammengehöriger Daten wie z. B. eine Liste von Namen, Benutzerdaten oder Konfigurationen. 
            Über Schleifen wie <code>foreach</code> kannst du bequem auf die einzelnen Elemente zugreifen und diese verarbeiten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// 1. Indiziertes Array (Zugriff über Zahlenindex)
$fruechte = ["Apfel", "Banane", "Kirsche"];
echo "Indiziertes Array:&lt;br&gt;";
echo $fruechte[0] . "&lt;br&gt;"; // Gibt "Apfel" aus
echo $fruechte[1] . "&lt;br&gt;"; // Gibt "Banane" aus
echo $fruechte[2] . "&lt;br&gt;&lt;br&gt;"; // Gibt "Kirsche" aus

// Durchlaufen mit foreach
foreach ($fruechte as $frucht) {
    echo "- $frucht&lt;br&gt;";
}

echo "&lt;br&gt;";

// 2. Assoziatives Array (Zugriff über benutzerdefinierte Schlüssel)
$benutzer = [
    "name" => "Max",
    "alter" => 32,
    "beruf" => "Backend Engineer"
];

echo "Assoziatives Array:&lt;br&gt;";
echo "Name: " . $benutzer["name"] . "&lt;br&gt;";
echo "Alter: " . $benutzer["alter"] . "&lt;br&gt;";
echo "Beruf: " . $benutzer["beruf"] . "&lt;br&gt;&lt;br&gt;";

// Durchlaufen mit foreach
foreach ($benutzer as $schluessel => $wert) {
    echo "$schluessel: $wert&lt;br&gt;";
}

echo "&lt;br&gt;";

// 3. Mehrdimensionales Array (Array innerhalb eines Arrays)
$produkte = [
    ["name" => "Tastatur", "preis" => 49.99],
    ["name" => "Maus", "preis" => 29.95],
    ["name" => "Monitor", "preis" => 199.00]
];

echo "Mehrdimensionales Array:&lt;br&gt;";
foreach ($produkte as $produkt) {
    echo "Produkt: " . $produkt["name"] . " – Preis: " . $produkt["preis"] . " CHF&lt;br&gt;";
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="assoarray">Assoziative Arrays</h1>
        <p>
            Ein <strong>assoziatives Array</strong> erlaubt es dir, jedem Wert einen benutzerdefinierten Schlüssel zuzuweisen – statt numerischer Indizes nutzt du z. B. Namen. 
            Das ist besonders nützlich, wenn du Daten wie Benutzerdetails oder Konfigurationen übersichtlich speichern und gezielt abrufen möchtest.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Assoziatives Array mit Benutzerdaten
$benutzer = [
    "vorname" => "Nathan",
    "nachname" => "Schmid",
    "alter" => 16
];

// Zugriff über benutzerdefinierte Schlüssel
echo "Vorname: " . $benutzer["vorname"] . "&lt;br&gt;";
echo "Nachname: " . $benutzer["nachname"] . "&lt;br&gt;";
echo "Alter: " . $benutzer["alter"] . "&lt;br&gt;";
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="supglobarray">Superglobale Arrays</h1>
        <p>
            PHP bietet spezielle vordefinierte Arrays, die als <strong>Superglobale Arrays</strong> bekannt sind. 
            Diese sind überall im Skript verfügbar und enthalten wichtige Informationen wie Formulardaten, 
            Serverdetails oder Session-Informationen. Beispiele sind <code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code> und <code>$_SERVER</code>.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>&lt;?php
// Start der Session, damit $_SESSION genutzt werden kann
session_start();

// Daten aus einem Formular (POST) auslesen
if (&lt;?php isset($_POST['username']) ?&gt;) {
    $_SESSION['user'] = $_POST['username'];  // Nutzername in Session speichern
}

// Prüfen, ob ein Benutzer angemeldet ist
if (isset($_SESSION['user'])) {
    echo 'Willkommen, ' . htmlspecialchars($_SESSION['user']) . '!';
} else {
    echo 'Bitte melden Sie sich an.';
}

// Server-Informationen anzeigen
echo '&lt;br&gt;Server-Protokoll: ' . $_SERVER['SERVER_PROTOCOL'];

// Zugriff auf URL-Parameter (GET)
$page = $_GET['page'] ?? 'startseite';
echo '&lt;br&gt;Aktuelle Seite: ' . htmlspecialchars($page);
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Formularverarbeitung">Formularverarbeitung</h1>
        <p>
            Formulardaten werden häufig über die Superglobalen Arrays <code>$_GET</code> und <code>$_POST</code> verarbeitet. 
            <code>$_GET</code> sammelt Daten, die über die URL übermittelt werden, während <code>$_POST</code> 
            Daten aus einem Formular sendet, ohne sie in der URL anzuzeigen. Nach dem Empfang der Daten kannst du sie validieren, 
            bereinigen und weiterverarbeiten – zum Beispiel in einer Datenbank speichern oder für die Anzeige nutzen. Wichtig ist dabei, 
            die Eingaben immer gegen unerwünschte Inhalte wie HTML oder SQL-Injection zu schützen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>index.html</h3>
        <pre><code>
&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER['PHP_SELF']); ?&gt;">

    &lt;label for="name"&gt;Name:&lt;/label&gt;
    &lt;input type="text" id="name" name="name" required&gt;

    &lt;br&gt;

    &lt;label for="email"&gt;E-Mail:&lt;/label&gt;
    &lt;input type="email" id="email" name="email" required&gt;

    &lt;br&gt;

    &lt;button type="submit"&gt;Absenden&lt;/button&gt;

&lt;/form&gt;
        </code></pre>
        <br>
        <h3>index.php</h3>
        <pre class="language-php"><code>
&lt;?php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Formular wurde abgeschickt, Daten auslesen
    $name = trim($_POST['name'] ?? '');
    $email = trim($_POST['email'] ?? '');
            
    // Einfache Validierung
    if (empty($name) || empty($email)) {
        echo 'Bitte alle Felder ausfüllen.';
    } elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        echo 'Bitte eine gültige E-Mail-Adresse eingeben.';
    } else {
        // Daten sind valide, weiterverarbeiten
        echo 'Hallo ' . htmlspecialchars($name) . ', deine E-Mail ' . htmlspecialchars($email) . ' wurde registriert.';
        // Hier könnte man die Daten z.B. in eine Datenbank schreiben
    }
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="sessioncookie">Session und Cookies</h1>
        <p>
            PHP verwendet <strong>Sessions</strong> und <strong>Cookies</strong>, um Daten zwischen verschiedenen Seitenaufrufen zu speichern. 
            Sessions speichern Informationen serverseitig und sind ideal für sensible Daten wie Login-Status. 
            Cookies werden im Browser gespeichert und können einfache Daten wie Einstellungen oder Benutzerpräferenzen enthalten. 
            Mit <code>session_start()</code> aktivierst du eine Session, und mit <code>setcookie()</code> legst du Cookies fest.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Session starten
session_start();
        
// Session-Daten setzen
$_SESSION['username'] = 'Max';
        
// Cookie setzen, gültig 1 Stunde
setcookie('theme', 'dark', time() + 3600);
        
// Ausgabe der Session- und Cookie-Daten
echo 'Angemeldeter Nutzer: ' . ($_SESSION['username'] ?? 'Gast') . '&lt;br&gt;';
echo 'Ausgewähltes Design: ' . ($_COOKIE['theme'] ?? 'Standard');
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Dateiverarbeitung">Dateiverarbeitung</h1>
        <p>
            In PHP kannst du Dateien lesen, schreiben und bearbeiten. 
            Mit Funktionen wie <code>fopen()</code>, <code>fread()</code> und <code>fwrite()</code> hast du volle Kontrolle über Dateioperationen. 
            Für einfache Lese- und Schreibvorgänge gibt es auch praktische Funktionen wie <code>file_get_contents()</code> und <code>file_put_contents()</code>. 
            Dabei ist es wichtig, immer auf Fehler zu prüfen und Zugriffsrechte zu beachten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
$filename = 'beispiel.txt';
        
// Text, der in die Datei geschrieben werden soll
$text = "Hallo Welt!\nDas ist eine Beispiel-Datei.\n";
        
// Datei öffnen zum Schreiben (w = überschreibt)
$handle = fopen($filename, 'w');
        
if ($handle) {
    // Schreiben in die Datei
    fwrite($handle, $text);
        
    // Weitere Zeile anhängen
    fwrite($handle, "Zusätzliche Zeile mit Datum: " . date('Y-m-d H:i:s') . "\n");
        
    fclose($handle);
    echo "Datei erfolgreich beschrieben.&lt;br&gt;";
} else {
    echo "Fehler beim Öffnen der Datei.&lt;br&gt;";
}
        
// Datei lesen und Inhalt ausgeben
if (file_exists($filename)) {
    $content = file_get_contents($filename);
    echo "Dateiinhalt:&lt;br&gt;" . nl2br(htmlspecialchars($content));
} else {
    echo "Datei existiert nicht.";
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Fehlerbehandlung">Fehlerbehandlung</h1>
        <p>
            PHP bietet mehrere Wege zur <strong>Fehlerbehandlung</strong>, etwa durch <code>try</code>–<code>catch</code>-Blöcke 
            für Ausnahmen, oder mit Funktionen wie <code>error_reporting()</code> und <code>set_error_handler()</code> für 
            benutzerdefinierte Fehler. Gerade bei Dateioperationen, Benutzereingaben oder Datenbankverbindungen solltest du 
            Fehler systematisch abfangen, um sauberes und sicheres Verhalten zu garantieren.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Fehleranzeige aktivieren (nur in der Entwicklung verwenden!)
error_reporting(E_ALL);
ini_set('display_errors', 1);
        
// Eigener Fehler-Handler
set_error_handler(function($errno, $errstr, $errfile, $errline) {
    echo "Benutzerdefinierter Fehler: [$errno] $errstr in $errfile Zeile $errline&lt;br&gt;";
    return true; // verhindert die Standard-Fehlerbehandlung
});
        
// Funktion zur Datei-Verarbeitung mit Fehlerbehandlung
function ladeDatei($pfad) {
    if (!file_exists($pfad)) {
        trigger_error("Datei '$pfad' wurde nicht gefunden.", E_USER_WARNING);
        return false;
    }
        
    $inhalt = file_get_contents($pfad);
    if ($inhalt === false) {
        trigger_error("Fehler beim Lesen der Datei '$pfad'.", E_USER_ERROR);
        return false;
    }
        
    return $inhalt;
}
        
// Funktion mit Exception
function berechne($a, $b) {
    if (!is_numeric($a) || !is_numeric($b)) {
        throw new InvalidArgumentException("Beide Werte müssen Zahlen sein.");
    }
    if ($b == 0) {
        throw new Exception("Division durch null ist nicht erlaubt.");
    }
    return $a / $b;
}
        
// Anwendung der Funktionen mit Fehlerbehandlung
try {
    $dateiInhalt = ladeDatei('daten.txt');
    if ($dateiInhalt !== false) {
        echo "Dateiinhalt:&lt;br&gt;" . nl2br(htmlspecialchars($dateiInhalt)) . "&lt;br&gt;&lt;br&gt;";
    }
        
    $ergebnis = berechne(10, 2);
    echo "Ergebnis der Division: $ergebnis&lt;br&gt;";
            
    // Test mit Fehler
    $ergebnis = berechne(10, 0);
} catch (InvalidArgumentException $e) {
    echo "Ungültiges Argument: " . $e-&gt;getMessage();
} catch (Exception $e) {
    echo "Fehler: " . $e-&gt;getMessage();
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="classobjs">Klassen und Objekte</h1>
        <p>
            PHP ist objektorientiert und unterstützt die Arbeit mit <strong>Klassen</strong> und <strong>Objekten</strong>. 
            Klassen sind Baupläne für Objekte und enthalten Eigenschaften (Variablen) und Methoden (Funktionen). 
            Du kannst damit strukturierte und wiederverwendbare Programme schreiben. 
            Wichtige Konzepte sind <code>public</code>, <code>private</code>, <code>constructor</code>, sowie Vererbung über <code>extends</code>.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Definition einer Klasse
class Benutzer {
    private $name;
    private $email;
        
    // Konstruktor wird beim Erstellen aufgerufen
    public function __construct($name, $email) {
        $this-&gt;name = $name;
        $this-&gt;email = $email;
    }
        
    // Öffentliche Methode zur Ausgabe
    public function vorstellung() {
        return "Ich bin $this-&gt;name und meine E-Mail ist $this-&gt;email.";
    }
        
    // Getter für Name
    public function getName() {
        return $this-&gt;name;
    }
}
        
// Objekt erzeugen
$nutzer = new Benutzer("Nathan", "nathan@example.com");
        
// Methoden verwenden
echo $nutzer-&gt;vorstellung();
        
// Zugriff über Getter
echo "&lt;br&gt;Name: " . $nutzer-&gt;getName();
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="oop">Einführung in OOP</h1>
        <p>
            Die objektorientierte Programmierung (OOP) ist ein zentraler Bestandteil moderner PHP-Anwendungen. 
            Sie erlaubt es dir, deinen Code besser zu strukturieren, übersichtlicher zu gestalten und wiederverwendbare 
            Module zu schaffen. Anstatt nur mit Funktionen und globalen Variablen zu arbeiten, werden in OOP sogenannte Klassen definiert. 
            Eine Klasse beschreibt ein Objekt in der realen Welt, zum Beispiel einen Benutzer oder ein Produkt, und enthält sowohl Eigenschaften 
            (also Daten, wie Name oder Preis) als auch Methoden (also Funktionen, die auf diesen Daten arbeiten).
        </p>
        
        <p>
            Ein Objekt ist eine Instanz einer Klasse – das heisst, es wird anhand des Bauplans (der Klasse) erzeugt und besitzt dann seine eigenen Werte 
            für die Eigenschaften. Mit dem Konstruktor (<code>__construct</code>) kannst du direkt beim Erstellen eines Objekts Startwerte setzen. 
            Sichtbarkeiten wie <code>public</code> oder <code>private</code> regeln dabei den Zugriff auf die Eigenschaften und Methoden – 
            so kannst du zum Beispiel sicherstellen, dass bestimmte Daten nicht von aussen manipuliert werden. 
            Ausserdem unterstützt PHP Vererbung, wodurch eine Klasse die Eigenschaften und Methoden einer anderen Klasse übernehmen kann. 
            Dadurch wird der Code noch modularer und flexibler. OOP ist besonders hilfreich bei grösseren Projekten, bei denen eine klare Trennung von Verantwortlichkeiten wichtig ist.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Eine Basisklasse für Benutzer
class Benutzer {
    private $name;
    private $email;
        
    // Konstruktor, wird beim Erstellen eines Objekts aufgerufen
    public function __construct($name, $email) {
        $this-&gt;name = $name;
        $this-&gt;email = $email;
    }
        
    // Öffentliche Methode zur Vorstellung
    public function vorstellen() {
        return "Ich heisse " . $this-&gt;name . " und meine E-Mail-Adresse ist " . $this-&gt;email . ".";
    }
        
    // Getter für den Namen
    public function getName() {
        return $this-&gt;name;
    }
        
    // Setter für den Namen
    public function setName($neuerName) {
        $this-&gt;name = $neuerName;
    }
}
        
// Eine abgeleitete Klasse für Administratoren
class Administrator extends Benutzer {
    private $rechte;
        
    public function __construct($name, $email, $rechte) {
        // Aufruf des Konstruktors der Elternklasse
        parent::__construct($name, $email);
        $this-&gt;rechte = $rechte;
    }
        
    // Überschreiben der vorstellen()-Methode
    public function vorstellen() {
        return parent::vorstellen() . " Ich bin Administrator mit folgenden Rechten: " . implode(", ", $this-&gt;rechte) . ".";
    }
}
        
// Einfache Nutzung der Klassen
$benutzer = new Benutzer("Nathan", "nathan@example.com");
echo $benutzer-&gt;vorstellen();
echo "&lt;br&gt;";
        
// Benutzername ändern
$benutzer-&gt;setName("Nathan D.");
echo "Neuer Name: " . $benutzer-&gt;getName();
echo "&lt;br&gt;&lt;br&gt;";
        
// Administrator-Objekt erzeugen
$admin = new Administrator("Lisa", "lisa@example.com", ["Benutzer löschen", "Einstellungen ändern"]);
echo $admin-&gt;vorstellen();
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="Vererbung">Vererbung</h1>
        <p>
            Vererbung ist ein grundlegendes Konzept der objektorientierten Programmierung in PHP. 
            Sie erlaubt es dir, eine neue Klasse zu erstellen, die die Eigenschaften und Methoden einer bestehenden Klasse übernimmt. 
            Dadurch kannst du Code wiederverwenden und erweitern, ohne ihn erneut schreiben zu müssen. Die Basis- oder Elternklasse wird mit dem 
            Schlüsselwort <code>class</code> definiert, und die abgeleitete Klasse verwendet <code>extends</code>, um von ihr zu erben. 
            Die Kindklasse kann Methoden der Elternklasse überschreiben oder eigene Methoden hinzufügen. Über <code>parent::</code> kannst du 
            explizit auf die Methoden der Elternklasse zugreifen, z.&nbsp;B. im Konstruktor oder bei einer überschriebenen Methode.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Elternklasse
class Fahrzeug {
    protected $marke;
    protected $geschwindigkeit;
        
    public function __construct($marke) {
        $this-&gt;marke = $marke;
        $this-&gt;geschwindigkeit = 0;
    }
        
    public function beschleunigen($kmh) {
        $this-&gt;geschwindigkeit += $kmh;
    }
        
    public function status() {
        return "Das Fahrzeug der Marke $this-&gt;marke fährt $this-&gt;geschwindigkeit km/h.";
    }
}
        
// Kindklasse, erbt von Fahrzeug
class Auto extends Fahrzeug {
    private $anzahlTueren;
        
    public function __construct($marke, $anzahlTueren) {
        parent::__construct($marke); // ruft den Konstruktor der Elternklasse auf
        $this-&gt;anzahlTueren = $anzahlTueren;
    }
        
    // Methode überschreiben
    public function status() {
        return parent::status() . " Es hat $this-&gt;anzahlTueren Türen.";
    }
}
        
// Objekt der Kindklasse erzeugen
$meinAuto = new Auto("Toyota", 4);
$meinAuto-&gt;beschleunigen(50);
echo $meinAuto-&gt;status();
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Polymorphismus">Polymorphismus</h1>
        <p>
            Polymorphismus bedeutet in der objektorientierten Programmierung, dass eine Methode je nach Kontext unterschiedlich funktioniert. 
            In PHP erreichst du das durch <strong>Methodenüberschreibung</strong> in abgeleiteten Klassen. 
            Eine Methode wird in der Elternklasse definiert und in der Kindklasse mit angepasstem Verhalten erneut implementiert. 
            Dadurch kannst du über einen einheitlichen Methodenaufruf unterschiedlich spezialisierte Objekte flexibel behandeln – ein Prinzip, 
            das besonders bei Vererbung und Schnittstellen nützlich ist.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Basisklasse
class Tier {
    protected $name;
        
    public function __construct($name) {
        $this-&gt;name = $name;
    }
        
    // Diese Methode wird von allen Unterklassen überschrieben
    public function geraeusch() {
        return "Unbekanntes Geräusch";
    }
        
    public function vorstellung() {
        return "Ich bin ein Tier namens $this-&gt;name und mache: " . $this-&gt;geraeusch();
    }
}
        
// Abgeleitete Klasse: Hund
class Hund extends Tier {
    public function geraeusch() {
        return "Wuff!";
    }
}
        
// Abgeleitete Klasse: Katze
class Katze extends Tier {
    public function geraeusch() {
        return "Miau!";
    }
}
        
// Abgeleitete Klasse: Kuh
class Kuh extends Tier {
    public function geraeusch() {
        return "Muh!";
    }
}
        
// Polymorphe Verwendung
$tiere = [
    new Hund("Bello"),
    new Katze("Mimi"),
    new Kuh("Elsa")
];
        
foreach ($tiere as $tier) {
    echo $tier-&gt;vorstellung() . "&lt;br&gt;";
}
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="abstrclass">Abstrakte Klassen</h1>
        <p>
            Abstrakte Klassen in PHP dienen als Vorlage für andere Klassen und können nicht direkt instanziiert werden. 
            Sie definieren allgemeine Eigenschaften und Methoden, die alle abgeleiteten Klassen gemeinsam haben sollen. 
            Enthält eine abstrakte Klasse <code>abstract</code>-Methoden, müssen diese zwingend in den Kindklassen implementiert werden. 
            Abstrakte Klassen helfen dabei, eine gemeinsame Schnittstelle für ähnliche Objekte zu schaffen, 
            während die konkrete Umsetzung den Unterklassen überlassen bleibt.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Abstrakte Basisklasse
abstract class FormularFeld {
    protected $name;
    protected $wert;
        
    public function __construct($name) {
        $this-&gt;name = $name;
        $this-&gt;wert = "";
    }
        
    public function setzeWert($wert) {
        $this-&gt;wert = $wert;
    }
        
    public function holeWert() {
        return $this-&gt;wert;
    }
        
    // Abstrakte Methode – muss von Kindklassen implementiert werden
    abstract public function rendern();
}
        
// Textfeld erbt von abstrakter Klasse
class TextFeld extends FormularFeld {
    public function rendern() {
        return '&lt;input type="text" name="' . $this-&gt;name . '" value="' . htmlspecialchars($this-&gt;wert) . '"&gt;';
    }
}
        
// Checkbox erbt von abstrakter Klasse
class Checkbox extends FormularFeld {
    public function rendern() {
        $gecheckt = $this-&gt;wert ? 'checked' : '';
        return '&lt;input type="checkbox" name="' . $this-&gt;name . '" ' . $gecheckt . '&gt;';
    }
}
        
// Felder erzeugen und anzeigen
$feld1 = new TextFeld("benutzername");
$feld1-&gt;setzeWert("Nathan");
        
$feld2 = new Checkbox("newsletter");
$feld2-&gt;setzeWert(true);
        
echo $feld1-&gt;rendern();
echo "&lt;br&gt;";
echo $feld2-&gt;rendern();
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="Interfaces">Interfaces</h1>
        <p>
            Ein Interface  definiert eine reine Schnittstelle – also eine Sammlung von Methodendeklarationen ohne konkrete Implementierung. 
            Klassen, die ein Interface implementieren, verpflichten sich, alle darin definierten Methoden umzusetzen. 
            Im Gegensatz zu Vererbung kannst du in PHP mehrere Interfaces gleichzeitig implementieren, was mehr Flexibilität bei der Strukturierung deines Codes bietet. 
            Interfaces sind besonders hilfreich, um einheitliche Strukturen in komplexen Anwendungen sicherzustellen, z.&nbsp;B. für Plugins, APIs oder verschiedene Datenquellen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Definition des Interfaces
interface Speichern {
    public function speichern();
    public function laden($id);
}
        
// Klasse, die das Interface implementiert
class Benutzer implements Speichern {
    private $id;
    private $name;
        
    public function __construct($id, $name) {
        $this-&gt;id = $id;
        $this-&gt;name = $name;
    }
        
    public function speichern() {
        // In einer echten App würdest du hier in eine Datenbank schreiben
        echo "Benutzer $this-&gt;name mit ID $this-&gt;id wurde gespeichert.&lt;br&gt;";
    }
        
    public function laden($id) {
        // Auch hier normalerweise: aus einer Datenbank laden
        echo "Benutzer mit ID $id wurde geladen.&lt;br&gt;";
    }
}
        
// Eine weitere Klasse, die das gleiche Interface verwendet
class Produkt implements Speichern {
    private $id;
    private $bezeichnung;
        
    public function __construct($id, $bezeichnung) {
        $this-&gt;id = $id;
        $this-&gt;bezeichnung = $bezeichnung;
    }
        
    public function speichern() {
        echo "Produkt '$this-&gt;bezeichnung' mit ID $this-&gt;id wurde gespeichert.&lt;br&gt;";
    }
        
    public function laden($id) {
        echo "Produkt mit ID $id wurde geladen.&lt;br&gt;";
    }
}
        
// Polymorphe Verwendung
$elemente = [
    new Benutzer(1, "Nathan"),
    new Produkt(101, "Laptop")
];
        
foreach ($elemente as $objekt) {
    $objekt-&gt;speichern();
    $objekt-&gt;laden(999);
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="dataobjs">PHP Data Objects</h1>
        <p>
            PHP Data Objects (PDO) ist eine einheitliche und sichere Schnittstelle für den Zugriff auf verschiedene Datenbanken wie MySQL, SQLite oder PostgreSQL. 
            PDO trennt die SQL-Logik von der Datenbankverbindung und schützt vor SQL-Injections durch vorbereitete Anweisungen (Prepared Statements). 
            Mit PDO kannst du flexibel zwischen Datenbanksystemen wechseln, ohne den Anwendungscode stark zu verändern. 
            Es bietet Methoden zum Abfragen, Einfügen und Aktualisieren von Daten auf sichere Weise.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Verbindung zur Datenbank herstellen (z. B. MySQL)
$dsn = "mysql:host=localhost;dbname=meine_datenbank;charset=utf8mb4";
$benutzer = "root";
$passwort = "";
        
try {
    // PDO-Instanz erstellen
    $pdo = new PDO($dsn, $benutzer, $passwort);
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        
    // Datensatz einfügen mit Prepared Statement
    $stmt = $pdo-&gt;prepare("INSERT INTO benutzer (name, email) VALUES (:name, :email)");
    $stmt-&gt;execute([
        ":name" =&gt; "Nathan",
        ":email" =&gt; "nathan@example.com"
    ]);
        
    echo "Benutzer erfolgreich eingefügt.&lt;br&gt;";
        
    // Daten auslesen
    $stmt = $pdo-&gt;query("SELECT * FROM benutzer");
        
    foreach ($stmt as $zeile) {
        echo "Name: " . htmlspecialchars($zeile["name"]) . " – E-Mail: " . htmlspecialchars($zeile["email"]) . "&lt;br&gt;";
    }
} catch (PDOException $e) {
    echo "Datenbankfehler: " . $e-&gt;getMessage();
}
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="MySQL">MySQL</h1>
        <p>
            MySQL ist ein weit verbreitetes, leistungsfähiges relationales Datenbankmanagementsystem, 
            das häufig in Kombination mit PHP verwendet wird, um dynamische Webanwendungen zu erstellen. 
            PHP bietet mehrere Möglichkeiten, mit MySQL zu kommunizieren – darunter <code>mysqli</code> und <code>PDO</code>. 
            Für neue Projekte empfiehlt sich PDO wegen seiner Flexibilität und Sicherheit. MySQL speichert Daten in Tabellen, 
            die aus Zeilen und Spalten bestehen. Du kannst mit SQL-Befehlen 
            wie <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> oder <code>DELETE</code> auf diese Daten zugreifen 
            und sie manipulieren.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Verbindung mit MySQL über mysqli
$verbindung = new mysqli("localhost", "root", "", "meine_datenbank");
        
// Verbindung prüfen
if ($verbindung-&gt;connect_error) {
    die("Verbindung fehlgeschlagen: " . $verbindung-&gt;connect_error);
}
        
// Datensatz einfügen
$sql = "INSERT INTO benutzer (name, email) VALUES ('Lisa', 'lisa@example.com')";
if ($verbindung-&gt;query($sql) === TRUE) {
    echo "Benutzer erfolgreich hinzugefügt.&lt;br&gt;";
} else {
    echo "Fehler: " . $verbindung-&gt;error;
}
        
// Datensätze abfragen
$sql = "SELECT id, name, email FROM benutzer";
$resultat = $verbindung-&gt;query($sql);
        
if ($resultat-&gt;num_rows &gt; 0) {
    while($zeile = $resultat-&gt;fetch_assoc()) {
        echo "ID: " . $zeile["id"] . " – Name: " . $zeile["name"] . " – E-Mail: " . $zeile["email"] . "&lt;br&gt;";
    }
} else {
    echo "Keine Benutzer gefunden.";
}
        
$verbindung-&gt;close();
?&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="prepstat">Prepared Statements</h1>
        <p>
            Prepared Statements (vorbereitete Anweisungen) bieten eine sichere und effiziente Möglichkeit, 
            SQL-Abfragen in PHP auszuführen – vor allem beim Umgang mit Benutzereingaben. 
            Anstatt Variablen direkt in SQL-Strings einzufügen, wird zunächst eine SQL-Vorlage mit Platzhaltern definiert. 
            Diese wird vom Datenbankserver vorbereitet, und erst danach werden die Werte gebunden und ausgeführt. 
            Das schützt zuverlässig vor SQL-Injection-Angriffen und verbessert bei wiederholten Abfragen auch die Performance.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Verbindung zur Datenbank über PDO
$dsn = "mysql:host=localhost;dbname=meine_datenbank;charset=utf8mb4";
$benutzer = "root";
$passwort = "";
        
try {
    $pdo = new PDO($dsn, $benutzer, $passwort);
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        
    // Benutzer über ein Formular registrieren (angenommen $_POST ist gesetzt)
    $name = $_POST["name"] ?? "Gast";
    $email = $_POST["email"] ?? "gast@example.com";
        
    // Vorbereitetes INSERT-Statement
    $stmt = $pdo-&gt;prepare("INSERT INTO benutzer (name, email) VALUES (:name, :email)");
    $stmt-&gt;bindParam(":name", $name);
    $stmt-&gt;bindParam(":email", $email);
    $stmt-&gt;execute();
        
    echo "Benutzer wurde sicher gespeichert.&lt;br&gt;";
        
    // Vorbereitetes SELECT mit Platzhaltern
    $stmt = $pdo-&gt;prepare("SELECT * FROM benutzer WHERE email = :email");
    $stmt-&gt;execute([":email" =&gt; $email]);
    $benutzer = $stmt-&gt;fetch();
        
    if ($benutzer) {
        echo "Willkommen, " . htmlspecialchars($benutzer["name"]) . "!";
    } else {
        echo "Benutzer nicht gefunden.";
    }
        
} catch (PDOException $e) {
    echo "Datenbankfehler: " . $e-&gt;getMessage();
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="crud">CRUD Operationen</h1>
        <p>
            CRUD steht für Create, Read, Update und Delete – die vier grundlegenden Operationen beim Umgang mit Datenbanken. 
            Mit PHP und PDO kannst du diese Operationen sicher und effizient durchführen. 
            <strong>Create</strong> fügt neue Datensätze ein, <strong>Read</strong> liest Daten aus, 
            <strong>Update</strong> ändert bestehende Einträge und <strong>Delete</strong> entfernt sie. 
            Durch Prepared Statements wird sichergestellt, dass Benutzereingaben korrekt verarbeitet und Sicherheitsrisiken wie SQL-Injection vermieden werden.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
$dsn = "mysql:host=localhost;dbname=meine_datenbank;charset=utf8mb4";
$benutzer = "root";
$passwort = "";
        
try {
    $pdo = new PDO($dsn, $benutzer, $passwort);
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        
    // CREATE – Benutzer einfügen
    $stmt = $pdo-&gt;prepare("INSERT INTO benutzer (name, email) VALUES (:name, :email)");
    $stmt-&gt;execute([
        ":name" =&gt; "Lena",
        ":email" =&gt; "lena@example.com"
    ]);
    echo "Benutzer erstellt.&lt;br&gt;";
        
    // READ – Benutzer anzeigen
    $stmt = $pdo-&gt;query("SELECT * FROM benutzer");
    foreach ($stmt as $zeile) {
        echo "ID: {$zeile['id']}, Name: {$zeile['name']}, E-Mail: {$zeile['email']}&lt;br&gt;";
    }
        
    // UPDATE – Benutzer aktualisieren
    $stmt = $pdo-&gt;prepare("UPDATE benutzer SET email = :email WHERE name = :name");
    $stmt-&gt;execute([
        ":email" =&gt; "lena.neu@example.com",
        ":name" =&gt; "Lena"
    ]);
    echo "Benutzer aktualisiert.&lt;br&gt;";
        
    // DELETE – Benutzer löschen
    $stmt = $pdo-&gt;prepare("DELETE FROM benutzer WHERE name = :name");
    $stmt-&gt;execute([":name" =&gt; "Lena"]);
    echo "Benutzer gelöscht.&lt;br&gt;";
        
} catch (PDOException $e) {
    echo "Fehler: " . $e-&gt;getMessage();
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="file">File Uploads</h1>
        <p>
            In PHP kannst du Benutzern das Hochladen von Dateien über ein HTML-Formular ermöglichen. PHP speichert hochgeladene Dateien zunächst in einem temporären Verzeichnis. Du kannst diese Datei anschließend mit der Funktion <code>move_uploaded_file()</code> an den gewünschten Ort verschieben. Dabei ist es wichtig, die Dateigröße und den MIME-Typ zu prüfen, um Sicherheitsprobleme wie das Hochladen ausführbarer Dateien zu vermeiden. Auch solltest du den Dateinamen bereinigen oder selbst vergeben.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>index.html</h3>
        <pre><code>
&lt;!-- HTML-Formular zum Hochladen einer Datei --&gt;
&lt;form action="upload.php" method="post" enctype="multipart/form-data"&gt;
    &lt;label for="datei"&gt;Wähle eine Datei:&lt;/label&gt;
    &lt;input type="file" name="datei" id="datei"&gt;&lt;br&gt;
    &lt;input type="submit" value="Hochladen"&gt;
&lt;/form&gt;
        </code></pre>
        <br>
        <h3>upload.php</h3>
        <pre class="language-php"><code>
&lt;?php
// upload.php – Verarbeitung des Datei-Uploads
if ($_SERVER["REQUEST_METHOD"] === "POST") {
    if (isset($_FILES["datei"]) &amp;&amp; $_FILES["datei"]["error"] === UPLOAD_ERR_OK) {
        $dateiname = basename($_FILES["datei"]["name"]);
        $zielverzeichnis = "uploads/";
        $zielpfad = $zielverzeichnis . $dateiname;
        
        // Prüfen, ob die Datei zu groß ist (z. B. &gt; 2MB)
        if ($_FILES["datei"]["size"] &gt; 2 * 1024 * 1024) {
            echo "Die Datei ist zu groß.";
            exit;
        }
        
        // Optional: Nur bestimmte Dateitypen erlauben
        $erlaubte_typen = ["image/jpeg", "image/png", "application/pdf"];
        if (!in_array($_FILES["datei"]["type"], $erlaubte_typen)) {
            echo "Dieser Dateityp ist nicht erlaubt.";
            exit;
        }
        
        // Datei verschieben
        if (move_uploaded_file($_FILES["datei"]["tmp_name"], $zielpfad)) {
            echo "Die Datei " . htmlspecialchars($dateiname) . " wurde erfolgreich hochgeladen.";
        } else {
            echo "Fehler beim Verschieben der Datei.";
        }
    } else {
        echo "Keine Datei wurde hochgeladen oder ein Fehler ist aufgetreten.";
    }
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Mailversand">Mailversand</h1>
        <p>
            PHP ermöglicht das Versenden von E-Mails direkt vom Server aus mit der Funktion <code>mail()</code>. 
            Diese Methode reicht für einfache E-Mails aus, hat jedoch Einschränkungen beim Versand von HTML-Mails, 
            Anhängen oder bei der Kompatibilität mit modernen Mailservern. Für professionelle Anwendungen empfiehlt sich der 
            Einsatz einer Bibliothek wie <strong>PHPMailer</strong>, die deutlich mehr Kontrolle bietet, 
            etwa bei Authentifizierung, SMTP-Versand und der Formatierung von Nachrichten. PHPMailer unterstützt HTML-Inhalte, 
            Anhänge und verschlüsselte Verbindungen, was sie besonders nützlich für produktionsreife Systeme macht.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>index.html</h3>
        <pre><code>&lt;!-- HTML-Formular zum Versenden einer E-Mail --&gt;
&lt;form action="sende_mail.php" method="post"&gt;

    &lt;label&gt;Dein Name:&lt;/label&gt;&lt;br&gt;
    &lt;input type="text" name="name" required&gt;&lt;br&gt;

    &lt;label&gt;Deine E-Mail:&lt;/label&gt;&lt;br&gt;
    &lt;input type="email" name="email" required&gt;&lt;br&gt;

    &lt;label&gt;Betreff:&lt;/label&gt;&lt;br&gt;
    &lt;input type="text" name="betreff" required&gt;&lt;br&gt;

    &lt;label&gt;Nachricht:&lt;/label&gt;&lt;br&gt;
    &lt;textarea name="nachricht" rows="6" cols="40" required&gt;&lt;/textarea&gt;&lt;br&gt;

    &lt;input type="submit" value="E-Mail senden"&gt;

&lt;/form&gt;
        </code></pre>
        <br>
        <h3>sende_mail.php</h3>
        <pre class="language-php"><code>
&lt;?php
// sende_mail.php – Mailversand mit PHPMailer (https://github.com/PHPMailer/PHPMailer)
// Voraussetzung: PHPMailer per Composer installiert (composer require phpmailer/phpmailer)
        
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
        
require 'vendor/autoload.php';
        
if ($_SERVER["REQUEST_METHOD"] === "POST") {
    $name = htmlspecialchars($_POST["name"]);
    $email = filter_var($_POST["email"], FILTER_VALIDATE_EMAIL);
    $betreff = htmlspecialchars($_POST["betreff"]);
    $nachricht = nl2br(htmlspecialchars($_POST["nachricht"]));
        
    if (!$email) {
        echo "Ungültige E-Mail-Adresse.";
        exit;
    }
        
    $mail = new PHPMailer(true);
        
    try {
        // Server-Einstellungen
        $mail-&gt;isSMTP();
        $mail-&gt;Host = 'smtp.example.com';                // SMTP-Server
        $mail-&gt;SMTPAuth = true;
        $mail-&gt;Username = 'dein-benutzer@example.com';   // SMTP-Benutzer
        $mail-&gt;Password = 'dein_passwort';               // SMTP-Passwort
        $mail-&gt;SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;
        $mail-&gt;Port = 587;
        
        // Absender und Empfänger
        $mail-&gt;setFrom('dein-benutzer@example.com', 'Webformular');
        $mail-&gt;addAddress('ziel@example.com', 'Admin'); // Empfängeradresse
        
        // Inhalt
        $mail-&gt;isHTML(true);
        $mail-&gt;Subject = $betreff;
        $mail-&gt;Body = "
            &lt;h2&gt;Neue Nachricht vom Kontaktformular&lt;/h2&gt;
            &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; $name&lt;/p&gt;
            &lt;p&gt;&lt;strong&gt;E-Mail:&lt;/strong&gt; $email&lt;/p&gt;
            &lt;p&gt;&lt;strong&gt;Nachricht:&lt;/strong&gt;&lt;br&gt; $nachricht&lt;/p&gt;
        ";
        $mail-&gt;AltBody = "Name: $name\nE-Mail: $email\nNachricht:\n" . strip_tags($nachricht);
        
        $mail-&gt;send();
        echo "E-Mail wurde erfolgreich gesendet.";
    } catch (Exception $e) {
        echo "E-Mail konnte nicht gesendet werden. Fehler: {$mail-&gt;ErrorInfo}";
    }
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="json">JSON Verarbeitung</h1>
        <p>
            PHP unterstützt die Verarbeitung von JSON-Daten nativ mit den Funktionen <code>json_encode()</code> und <code>json_decode()</code>. 
            Damit kannst du Datenstrukturen wie Arrays oder Objekte einfach in JSON umwandeln und umgekehrt. 
            Dies ist besonders nützlich für die Kommunikation zwischen Server und JavaScript im Browser oder beim Austausch mit APIs. 
            Während <code>json_encode()</code> PHP-Daten in einen JSON-String umwandelt, 
            konvertiert <code>json_decode()</code> einen JSON-String wieder in ein PHP-Array oder -Objekt.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Beispiel: PHP-Array zu JSON
$daten = [
    "name" =&gt; "Anna",
    "alter" =&gt; 25,
    "interessen" =&gt; ["Programmieren", "Musik", "Reisen"]
];
        
$jsonString = json_encode($daten, JSON_PRETTY_PRINT);
echo "JSON-Ausgabe:&lt;br&gt;&lt;pre&gt;$jsonString&lt;/pre&gt;";
        
// Beispiel: JSON zu PHP-Array
$eingehendesJSON = '{"name":"Max","alter":30,"interessen":["Lesen","Sport"]}';
$phpArray = json_decode($eingehendesJSON, true); // true = assoziatives Array
        
echo "&lt;br&gt;Name: " . $phpArray["name"] . "&lt;br&gt;";
echo "Alter: " . $phpArray["alter"] . "&lt;br&gt;";
echo "Erstes Interesse: " . $phpArray["interessen"][0] . "&lt;br&gt;";
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="restapi">RESTful APIs</h1>
        <p>
            RESTful APIs sind eine weit verbreitete Architektur, um Daten über das Web auszutauschen. 
            Sie nutzen HTTP-Methoden wie GET, POST, PUT und DELETE, um auf Ressourcen zuzugreifen oder sie zu verändern. 
            In PHP kannst du REST-APIs erstellen, indem du HTTP-Anfragen auswertest und entsprechende JSON-Antworten zurückgibst. 
            Dabei ist es wichtig, den richtigen HTTP-Statuscode zu senden und Eingaben sorgfältig zu validieren. 
            RESTful APIs sind besonders praktisch für die Kommunikation zwischen verschiedenen Systemen oder Frontend und Backend.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-php"><code>
&lt;?php
// Einfaches RESTful API-Beispiel in PHP
        
header("Content-Type: application/json; charset=utf-8");
        
// Beispiel-Daten als Array
$benutzer = [
    1 =&gt; ["id" =&gt; 1, "name" =&gt; "Anna", "email" =&gt; "anna@example.com"],
    2 =&gt; ["id" =&gt; 2, "name" =&gt; "Ben", "email" =&gt; "ben@example.com"]
];
        
$method = $_SERVER["REQUEST_METHOD"];
$request = explode("/", trim($_SERVER["REQUEST_URI"], "/"));
$ressource = $request[0] ?? null;
$id = $request[1] ?? null;
        
if ($ressource !== "benutzer") {
    http_response_code(404);
    echo json_encode(["error" =&gt; "Ressource nicht gefunden"]);
    exit;
}
        
switch ($method) {
    case "GET":
        if ($id) {
            if (isset($benutzer[$id])) {
                echo json_encode($benutzer[$id]);
            } else {
                http_response_code(404);
                echo json_encode(["error" =&gt; "Benutzer nicht gefunden"]);
            }
        } else {
            echo json_encode(array_values($benutzer));
        }
        break;
        
    case "POST":
        $input = json_decode(file_get_contents("php://input"), true);
        if (!empty($input["name"]) &amp;&amp; !empty($input["email"])) {
            $neueId = max(array_keys($benutzer)) + 1;
            $benutzer[$neueId] = ["id" =&gt; $neueId, "name" =&gt; $input["name"], "email" =&gt; $input["email"]];
            http_response_code(201);
            echo json_encode($benutzer[$neueId]);
        } else {
            http_response_code(400);
            echo json_encode(["error" =&gt; "Ungültige Eingabedaten"]);
        }
        break;
        
    case "PUT":
        if (!$id || !isset($benutzer[$id])) {
            http_response_code(404);
            echo json_encode(["error" =&gt; "Benutzer nicht gefunden"]);
            break;
        }
        $input = json_decode(file_get_contents("php://input"), true);
        if (!empty($input["name"])) {
            $benutzer[$id]["name"] = $input["name"];
        }
        if (!empty($input["email"])) {
            $benutzer[$id]["email"] = $input["email"];
        }
        echo json_encode($benutzer[$id]);
        break;
        
    case "DELETE":
        if (!$id || !isset($benutzer[$id])) {
            http_response_code(404);
            echo json_encode(["error" =&gt; "Benutzer nicht gefunden"]);
            break;
        }
        unset($benutzer[$id]);
        http_response_code(204); // No Content
        break;
        
    default:
        http_response_code(405);
        echo json_encode(["error" =&gt; "Methode nicht erlaubt"]);
        break;
}
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="Composer">Composer</h1>
        <p>
            Composer ist der de-facto Paketmanager für PHP, der das Verwalten von Bibliotheken und Abhängigkeiten in Projekten vereinfacht. 
            Mit Composer kannst du externe Pakete herunterladen, automatisch laden (Autoloading) und auf dem aktuellen Stand halten, ohne sie manuell verwalten zu müssen. 
            Er arbeitet über eine zentrale Datei namens <code>composer.json</code>, in der du festlegst, welche Pakete dein Projekt benötigt. 
            Composer löst die Abhängigkeiten dieser Pakete automatisch auf und sorgt für eine saubere Organisation im Verzeichnis <code>vendor/</code>. 
            Das erleichtert die Zusammenarbeit in Teams und sorgt für reproduzierbare Entwicklungsumgebungen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>composer.json</h3>
        <pre><code>
// Beispiel: composer.json - definiert ein Projekt mit Abhängigkeit zu PHPMailer
// Datei: composer.json
        
{
    "require": {
        "phpmailer/phpmailer": "^6.8"
    }
}
        </code></pre>
        <br>
        <h3>Kommandozeile</h3>
        <pre><code>
# Kommandozeile - Paket installieren
composer install
        </code></pre>
        <br>
        <h3>index.php</h3>
        <pre class="language-php"><code>
&lt;?php
require 'vendor/autoload.php';
            
use PHPMailer\PHPMailer\PHPMailer;
            
$mail = new PHPMailer();
$mail-&gt;setFrom('test@example.com');
$mail-&gt;addAddress('empfaenger@example.com');
$mail-&gt;Subject = 'Test Mail mit Composer';
$mail-&gt;Body = 'Dies ist eine Test-Mail.';
$mail-&gt;send();
echo 'Mail wurde gesendet.';
?&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="ut">Unit Testing</h1>
        <p>
            Unit Testing bedeutet, einzelne Komponenten oder Funktionen isoliert zu testen, um sicherzustellen, 
            dass sie korrekt funktionieren. Dabei schreibt man kleine, unabhängige Tests, die die erwarteten Eingaben und Ausgaben prüfen. 
            Die populärste Bibliothek für Unit Tests in PHP ist <strong>PHPUnit</strong>. 
            Sie ermöglicht automatisiertes Testen und hilft, Fehler früh zu erkennen und den Code stabiler zu machen. 
            Unit Tests sind die Basis für sauberen, wartbaren Code und eine wichtige Praxis in der professionellen Softwareentwicklung.
        </p>
        <h2>Beispiel</h2>
        <br>
        <pre class="language-php"><code>
&lt;?php
// Beispiel: Eine einfache Klasse mit einer Methode, die wir testen wollen
            
class Rechner {
    public function addiere(int $a, int $b): int {
        return $a + $b;
    }
}
?&gt;
        </code></pre>
        <br>
        <pre class="language-php"><code>
# PHPUnit-Testklasse (Datei RechnerTest.php)
# Benötigt PHPUnit (via Composer installierbar: composer require --dev phpunit/phpunit)
        
&lt;?php
use PHPUnit\Framework\TestCase;
        
class RechnerTest extends TestCase {
    public function testAddiere() {
        $rechner = new Rechner();
        $ergebnis = $rechner->addiere(3, 4);
        $this-&gt;assertEquals(7, $ergebnis, "3 + 4 sollte 7 ergeben");
    }
}
?&gt;
        </code></pre>
    </main>

    <script>
        function scrollNav(amount) {
            document.getElementById('navWrapper').scrollBy({ left: amount, behavior: 'smooth' });
        }
    </script>
</body>
</html>