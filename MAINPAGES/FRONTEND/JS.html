<!DOCTYPE html>
<html lang = "de">
<head>
    <title>JS</title>
    <meta charset = "UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary-color: #ffe100;
            --hover-color: #ECDC68;
            --bg-primary: #1e1e1e;
            --bg-secondary: #141414;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2d2d2d;
        }

        html, body {
            background-color: #1e1e1e !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Dela Gothic One', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        header {
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            padding: 3rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        header img {
            height: 80px;
            width: 80px;
            object-fit: contain;
            border-radius: 12px;
        }

        header h1 {
            font-size: 3rem;
            color: var(--text-primary);
            font-weight: normal;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sticky-nav-container {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
        }

        .nav-scroll-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            padding: 0 1rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .nav-scroll-btn:hover {
            color: var(--primary-color);
        }

        .nav-wrapper {
            overflow-x: auto;
            white-space: nowrap;
            flex: 1;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .nav-wrapper::-webkit-scrollbar {
            display: none;
        }

        nav ul {
            display: inline-flex;
            list-style: none;
            gap: 1rem;
            padding: 0 1rem;
        }

        nav a {
            text-decoration: none;
            color: var(--text-primary);
            font-size: 0.85rem;
            padding: 0.4rem 0.75rem;
            border-radius: 0.25rem;
            transition: 0.2s ease;
            white-space: nowrap;
        }

        nav a:hover {
            color: var(--primary-color);
        }

        main {
            padding: 2rem;
        }

        main h1 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        main h2 {
            margin-top: 2rem;
            font-size: 1.5rem;
            color: var(--hover-color);
        }

        main p {
            font-family: 'Source Sans 3', sans-serif;
            margin-top: 1rem;
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .hljs,
        .hljs * {
            background: none !important;
        }

        pre {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            margin-top: 1rem;
        }

        code {
            font-family: monospace;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <header>
        <img src="LOGO/js.png" alt="JS Logo 3D">
        <h1>JavaScript</h1>
    </header>
    <div class="sticky-nav-container">
        <button class="nav-scroll-btn" onclick="scrollNav(-200)">&#x25C0;</button>
        <div class="nav-wrapper" id="navWrapper">
            <nav>
                <ul>
                    <li><a href="#intro">Einführung</a></li>
                    <li><a href="#src">script src</a></li>
                    <li><a href="#variables">Variablen</a></li>
                    <li><a href="#types">Datentypen</a></li>
                    <li><a href="#operators">Operatoren</a></li>
                    <li><a href="#if">if</a></li>
                    <li><a href="#elseif">else if</a></li>
                    <li><a href="#else">else</a></li>
                    <li><a href="#switch">switch</a></li>
                    <li><a href="#for">for</a></li>
                    <li><a href="#while">while</a></li>
                    <li><a href="#dowhile">do... while</a></li>
                    <li><a href="#forin">for... in</a></li>
                    <li><a href="#forof">for... of</a></li>
                    <li><a href="#functions">Funktionen</a></li>
                    <li><a href="#methods">Methoden</a></li>
                    <li><a href="#objects">Objekte</a></li>
                    <li><a href="#arrays">Arrays</a></li>
                    <li><a href="#push">push</a></li>
                    <li><a href="#pop">pop</a></li>
                    <li><a href="#shift">shift</a></li>
                    <li><a href="#unshift">unshift</a></li>
                    <li><a href="#map">map</a></li>
                    <li><a href="#filter">filter</a></li>
                    <li><a href="#reduce">reduce</a></li>
                    <li><a href="#getElementById">getElementById</a></li>
                    <li><a href="#querySelector">querySelector</a></li>
                    <li><a href="#innerHTML">innerHTML</a></li>
                    <li><a href="#textContent">textContent</a></li>
                    <li><a href="#style">style</a></li>
                    <li><a href="#addEventListener">addEventListener</a></li>
                    <li><a href="#async">async</a></li>
                    <li><a href="#await">await</a></li>
                    <li><a href="#trycatch">try... catch</a></li>
                    <li><a href="#class">class</a></li>
                    <li><a href="#constructor">constructor</a></li>
                    <li><a href="#extends">extends</a></li>
                    <li><a href="#super">super</a></li>
                    <li><a href="#import">import</a></li>
                    <li><a href="#export">export</a></li>
                    <li><a href="#fetch">fetch</a></li>
                    <li><a href="#XMLHttpRequest">XMLHttpRequest</a></li>
                    <li><a href="#localStorage">localStorage</a></li>
                    <li><a href="#sessionStorage">sessionStorage</a></li>
                </ul>
            </nav>
        </div>
        <button class="nav-scroll-btn" onclick="scrollNav(200)">&#x25B6;</button>
    </div>

    <main>
        <h1 id="intro">Einführung</h1>
        <p>JavaScript ist die Programmiersprache des Webs und wird verwendet, um Webseiten interaktiv und dynamisch zu machen. 
            Während HTML für die Struktur und CSS für das Aussehen zuständig ist, sorgt JavaScript dafür, dass sich Dinge auf der Seite bewegen, reagieren oder verändern. 
            Du kannst damit z. B. auf Klicks reagieren, Inhalte verändern, Animationen abspielen oder Daten verarbeiten. 
            JavaScript läuft direkt im Browser und ist ein unverzichtbarer Bestandteil moderner Webseiten. 
            Ohne JavaScript wären viele Funktionen, die wir täglich im Web nutzen, nicht möglich – von einfachen Bildergalerien bis hin zu komplexen Webanwendungen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-html"><code>
&lt;!DOCTYPE html&gt;
&lt;html lang="de"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Einfaches JavaScript Beispiel&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;h1 id="headline"&gt;Hallo!&lt;/h1&gt;
    &lt;button onclick="changeText()"&gt;Klick mich&lt;/button&gt;

    &lt;script&gt;
        // Das ist JavaScript
        function changeText() {
            document.getElementById("headline").innerText = "Du hast geklickt!";
        }
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="src">script src</h1>
        <p>
            Der &lt;script&gt; Tag mit dem Attribut <code>src</code> wird verwendet, 
            um externe JavaScript-Dateien in eine HTML-Seite einzubinden. 
            Anstatt den JavaScript-Code direkt im HTML-Dokument zu schreiben, 
            verweist man mit <code>src</code> auf eine separate Datei. Das sorgt für bessere Übersicht, 
            Wiederverwendbarkeit und einfachere Wartung des Codes. Der Browser lädt die externe Datei 
            und führt den darin enthaltenen JavaScript-Code aus, sobald das &lt;script&gt;-Element erreicht wird. 
            Ohne das <code>src</code>-Attribut kann man auch Inline-JavaScript im &lt;script&gt;-Tag schreiben.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;!DOCTYPE html&gt;
&lt;html lang="de"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Beispiel Script src&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Willkommen&lt;/h1&gt;

    &lt;!-- Externe JavaScript-Datei einbinden --&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
        </code></pre>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
// Dies ist der JavaScript-Code in der externen Datei
console.log('Hallo aus der externen Datei!');
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="variables">Variablen</h1>
        <p>
            In JavaScript kannst du mit <strong>Variablen</strong> und <strong>Konstanten</strong> Daten speichern, 
            die du später im Code wiederverwenden willst. Variablen werden mit dem Schlüsselwort <code>let</code> oder <code>var</code> 
            deklariert und können ihren Wert später ändern. Konstanten hingegen werden mit <code>const</code> erstellt und behalten ihren Wert – sie 
            dürfen nach der Zuweisung nicht mehr verändert werden. Die Verwendung von <code>let</code> und <code>const</code> ist moderner 
            und sicherer als <code>var</code>, weshalb du sie bevorzugen solltest. Durch den gezielten Einsatz von Variablen und Konstanten 
            strukturierst du deinen Code übersichtlich und vermeidest unnötige Wiederholungen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Eine Variable mit let – der Wert kann später verändert werden
let name = "Anna";
console.log(name); // Ausgabe: Anna

name = "Luca";
console.log(name); // Ausgabe: Luca

// Eine Konstante mit const – der Wert bleibt gleich
const geburtsjahr = 2008;
console.log(geburtsjahr); // Ausgabe: 2008

// folgender Versuch würde einen Fehler auslösen:
// geburtsjahr = 2010; Das ist nicht erlaubt
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="types">Datentypen</h1>
        <p>JavaScript ist eine dynamisch typisierte Sprache – das bedeutet, dass du beim Erstellen 
            von Variablen keinen bestimmten Datentyp angeben musst. Im Gegensatz zu vielen anderen S
            prachen kennt JavaScript keine festen Datentypen für Variablen. Der Typ wird automatisch zur 
            Laufzeit bestimmt – je nachdem, welcher Wert gespeichert wird. So kann eine Variable zum Beispiel 
            zuerst einen Text (String) und später eine Zahl enthalten. Das macht JavaScript sehr flexibel, 
            erfordert aber auch, dass du genau darauf achtest, welche Art von Daten du verwendest, um Fehler zu vermeiden.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
let variable = "Hallo Welt";   // aktuell ein String
console.log(variable);         // Ausgabe: Hallo Welt

variable = 42;                 // jetzt ist es eine Zahl
console.log(variable);         // Ausgabe: 42

variable = true;               // jetzt ist es ein Boolean
console.log(variable);         // Ausgabe: true
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="operators">Operatoren</h1>
        <p>Operatoren in JavaScript sind Symbole oder Schlüsselwörter, mit denen du Werte verarbeiten, 
            vergleichen oder verändern kannst. Zum Beispiel kannst du mit dem Pluszeichen <code>+</code> 
            zwei Zahlen addieren oder Texte (Strings) verbinden. Es gibt verschiedene Arten von Operatoren: <strong>arithmetische Operatoren</strong> 
            (wie <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), <strong>Vergleichsoperatoren</strong> 
            (wie <code>==</code>, <code>===</code>, <code>&lt;</code>, <code>&gt;</code>), <strong>logische Operatoren</strong> 
            (wie <code>&&</code>, <code>||</code>, <code>!</code>) und <strong>Zuweisungsoperatoren</strong> 
            (wie <code>=</code>, <code>+=</code>, <code>*=</code>). Mit Operatoren kannst du also Rechnungen durchführen, 
            Bedingungen prüfen oder Werte in Variablen speichern – sie sind ein zentraler Bestandteil jeder Programmiersprache.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Arithmetische Operatoren
let a = 10;
let b = 3;

let summe = a + b;          // + Addieren → 10 + 3 = 13
let differenz = a - b;      // - Subtrahieren → 10 - 3 = 7
let produkt = a * b;        // * Multiplizieren → 10 * 3 = 30
let quotient = a / b;       // / Dividieren → 10 / 3 ≈ 3.333
let rest = a % b;           // % Modulo (Rest) → 10 % 3 = 1

console.log("Summe:", summe);
console.log("Differenz:", differenz);
console.log("Produkt:", produkt);
console.log("Quotient:", quotient);
console.log("Rest:", rest);

// Vergleichsoperatoren
console.log(a == 10);           // == prüft auf Gleichheit (Wert) → true
console.log(a === "10");        // === prüft auf Gleichheit (Wert + Typ) → false
console.log(b != 5);            // != ungleich → true
console.log(a &gt; b);          // grösser als → true
console.log(b &lt; 5);          // kleiner als → true

// Logische Operatoren
let x = true;
let y = false;

console.log(x && y);    // UND (&&) → true && false = false
console.log(x || y);    // ODER (||) → true || false = true
console.log(!x);        // NICHT (!) → !true = false

// Zuweisungsoperatoren
let zahl = 5;

zahl += 2;      // entspricht: zahl = zahl + 2 → 7
zahl *= 3;      // entspricht: zahl = zahl * 3 → 21

console.log("Ergebnis nach Zuweisungen:", zahl);
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="if">if</h1>
        <p>
            Die <code>if</code>-Anweisung ist eine der wichtigsten Kontrollstrukturen in JavaScript. 
            Mit ihr kannst du Entscheidungen treffen: Der Code innerhalb des <code>if</code>-Blocks wird nur ausgeführt, wenn eine bestimmte Bedingung erfüllt ist – also <code>true</code> ergibt. 
            Damit kannst du Programme schreiben, die auf unterschiedliche Situationen flexibel reagieren, z. B. je nach Benutzereingabe oder Datenlage. 
            Häufig wird <code>if</code> auch mit <code>else</code> oder <code>else if</code> kombiniert, um mehrere Bedingungen zu prüfen. 
            So kannst du den Ablauf deines Programms gezielt steuern und intelligentes Verhalten ermöglichen.
        </p>
        <h2>Beispiel</h2>  
        <pre class="language-javascript"><code>
let alter = 18;

if (alter >= 18) {
    console.log("Du bist volljährig.");
} else {
    console.log("Du bist noch nicht volljährig.");
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="elseif">else if</h1>
        <p>
            Die <code>else if</code>-Anweisung in JavaScript ermöglicht es dir, mehrere Bedingungen hintereinander zu prüfen. 
            Wenn die erste <code>if</code>-Bedingung nicht zutrifft, wird die nächste <code>else if</code>-Bedingung getestet – und so weiter. 
            So kannst du komplexere Entscheidungsstrukturen bauen, bei denen du auf verschiedene Fälle unterschiedlich reagieren willst. 
            Wird eine der Bedingungen erfüllt, wird nur der zugehörige Codeblock ausgeführt – die restlichen Bedingungen werden übersprungen. 
            <code>else if</code> sorgt also für mehr Flexibilität in deinen Programmen und hilft dir, klar strukturierte Abläufe zu gestalten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
let note = 3;

if (note === 1) {
    console.log("Sehr gut");
} else if (note === 2) {
    console.log("Gut");
} else if (note === 3) {
    console.log("Befriedigend");
} else if (note === 4) {
    console.log("Ausreichend");
} else if (note === 5) {
    console.log("Mangelhaft");
} else if (note === 6) {
    console.log("Ungenügend");
} else {
    console.log("Ungültige Note");
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="else">else</h1>
        <p>
            Die <code>else</code>-Anweisung in JavaScript gehört zu einer <code>if</code>-Struktur und wird verwendet, um eine Alternative auszuführen, falls keine der vorherigen Bedingungen zutrifft. 
            Wenn also weder die <code>if</code>- noch eine mögliche <code>else if</code>-Bedingung erfüllt ist, greift der <code>else</code>-Block. 
            Das ist besonders nützlich, wenn du sicherstellen möchtest, dass in jedem Fall eine Reaktion erfolgt – selbst wenn du nicht alle möglichen Werte explizit abfragst. 
            <code>else</code> steht dabei immer am Ende der Bedingungskette und fängt sozusagen „alle anderen Fälle“ auf.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
let alter = 15;

if (alter >= 18) {
    console.log("Du bist volljährig.");
} else {
    console.log("Du bist noch nicht volljährig.");
}   
        </code></pre>
    
        <br>
        <br>
        <br>

        <h1 id="switch">switch</h1>
        <p>
            Das <code>switch</code>-Statement in JavaScript ist eine Alternative zu mehreren <code>if...else if</code>-Bedingungen und eignet sich besonders gut, wenn du eine Variable auf viele mögliche Werte überprüfen möchtest. 
            Statt viele <code>if</code>-Abfragen hintereinander zu schreiben, kannst du mit <code>switch</code> übersichtlicher und klarer festlegen, was bei welchem Fall passieren soll. 
            Jeder mögliche Wert wird mit einem <code>case</code> geprüft, und mit <code>break</code> wird der jeweilige Fall beendet. 
            Ein optionaler <code>default</code>-Block kann genutzt werden, wenn kein anderer Fall zutrifft.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
let farbe = "rot";

switch (farbe) {
    case "blau":
        console.log("Die Farbe ist blau.");
        break;
    case "rot":
        console.log("Die Farbe ist rot.");
        break;
    default:
        console.log("Unbekannte Farbe.");
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="for">for</h1>
        <p>
            Die <code>for</code>-Schleife ist eine der meistgenutzten Schleifen in JavaScript und wird verwendet, um Code mehrfach auszuführen – solange eine bestimmte Bedingung erfüllt ist. 
            Sie besteht aus drei Teilen: einer Start-Anweisung, einer Bedingung und einer Schritt-Anweisung. 
            Typischerweise wird sie verwendet, um durch Zahlen zu zählen oder über Arrays zu iterieren. 
            Die <code>for</code>-Schleife ist besonders dann praktisch, wenn du genau weisst, wie oft sich ein Vorgang wiederholen soll.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Wir wollen die Zahlen von 1 bis 5 in der Konsole ausgeben
for (let i = 1; i &lt;= 5; i++) {
    console.log(i);
}
        </code></pre>

        <br>
        <br>
        <br>
        
        <h1 id="while">while</h1>
        <p>
            Die <code>while</code>-Schleife wird verwendet, um einen Codeblock so lange wiederholt auszuführen, wie eine bestimmte Bedingung wahr ist. 
            Im Gegensatz zur <code>for</code>-Schleife ist die <code>while</code>-Schleife besonders dann nützlich, wenn man nicht genau weiss, wie oft ein Vorgang wiederholt werden muss. 
            Bevor der Schleifeninhalt ausgeführt wird, wird die Bedingung geprüft – ist sie <code>true</code>, läuft die Schleife weiter, ist sie <code>false</code>, wird sie beendet. 
            Es ist wichtig, innerhalb der Schleife dafür zu sorgen, dass die Bedingung irgendwann <code>false</code> wird, sonst läuft die Schleife unendlich weiter.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Startwert setzen
let zahl = 1;
            
// Schleife läuft so lange, wie zahl kleiner oder gleich 5 ist
while (zahl &lt;= 5) {
    console.log("Aktuelle Zahl ist: " + zahl);
              
    // Zahl um 1 erhöhen, damit die Schleife irgendwann endet
    zahl++;
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="dowhile">do... while</h1>
        <p>
            Die <code>do...while</code>-Schleife ähnlich wie eine <code>while</code>-Schleife – mit einem wichtigen Unterschied: 
            Der Code im <code>do</code>-Block wird mindestens einmal ausgeführt, egal ob die Bedingung stimmt oder nicht. 
            Erst nach dem ersten Durchlauf wird die Bedingung geprüft und entschieden, ob die Schleife weiterläuft. 
            Das ist besonders dann nützlich, wenn du willst, dass ein Vorgang mindestens einmal durchgeführt wird – zum Beispiel eine Benutzereingabe abfragen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
let eingabe;

do {
    eingabe = prompt("Gib das Passwort ein:");
} while (eingabe !== "geheim");
            
alert("Zugriff erlaubt!");          
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="forin">for... in</h1>
        <p> Die Schleife <code>for...in</code> wird verwendet, um über die <strong>Eigenschaften eines Objekts</strong> zu iterieren. 
            Sie eignet sich besonders gut, wenn du alle Schlüssel (Property-Namen) eines Objekts nacheinander durchgehen möchtest – unabhängig davon, 
            wie viele es sind oder wie sie heissen. Dabei greifst du jeweils auf den Namen der Eigenschaft zu und kannst diesen z. B. nutzen, um den zugehörigen Wert abzurufen. 
            Allerdings sollte <code>for...in</code> mit Vorsicht verwendet werden, da sie auch vererbte Eigenschaften aus der Prototyp-Kette mit einschliesst. 
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
const auto = {
    marke: "Toyota",
    modell: "Corolla",
    baujahr: 2020
};
              
for (let eigenschaft in auto) {
    console.log(eigenschaft + ": " + auto[eigenschaft]);
}    
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="forof">for... of</h1>
        <p> Die <code>for...of</code>-Schleife ist eine moderne und einfache Möglichkeit, über Iterable-Objekte in JavaScript zu iterieren – also z. B. über Arrays, Strings, Maps oder Sets. 
            Im Gegensatz zur <code>for...in</code>-Schleife, die über Eigenschaftsnamen eines Objekts läuft, arbeitet <code>for...of</code> direkt mit den Werten selbst. Das macht sie besonders 
            leserlich und praktisch, wenn du einfach über Inhalte gehen willst – etwa bei einer Liste von Zahlen oder Zeichen. <code>for...of</code> funktioniert nur mit sogenannten "iterierbaren" 
            Objekten und ist nicht geeignet, um durch die Eigenschaften von normalen Objekten zu gehen. 
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
const farben = ["Rot", "Grün", "Blau"];

for (const farbe of farben) {
    console.log(farbe);
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="functions">Funktionen</h1>
        <p>
            Funktionen in JavaScript sind eigenständige Codeblöcke, die eine bestimmte Aufgabe ausführen und bei Bedarf mehrfach aufgerufen werden können. 
            Sie helfen dabei, Code übersichtlich, wiederverwendbar und logisch strukturiert zu gestalten. 
            Funktionen können Eingabewerte (sogenannte Parameter) entgegennehmen und ein Ergebnis zurückgeben. 
            Du kannst eigene Funktionen definieren oder auf eine Vielzahl integrierter Funktionen zurückgreifen, die JavaScript bereits mitbringt. 
            Funktionen sind ein zentrales Konzept in JavaScript – ohne sie wäre strukturierte Programmierung kaum möglich.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Funktion, die zwei Zahlen addiert und das Ergebnis zurückgibt
function addiere(zahl1, zahl2) {
    return zahl1 + zahl2;
}

// Funktion aufrufen und Ergebnis ausgeben
const ergebnis = addiere(5, 3);
console.log(ergebnis); // Ausgabe: 8
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="methods">Methoden</h1>
        <p>
            Methoden in JavaScript sind Funktionen, die an Objekte gebunden sind und deren Verhalten oder Eigenschaften beeinflussen. 
            Sie ermöglichen es dir, Aktionen auf den Daten eines Objekts auszuführen oder diese zu verändern. 
            Fast alle Datentypen in JavaScript, wie Arrays, Strings oder Objekte, besitzen eigene Methoden, die dir praktische Werkzeuge an die Hand geben – zum Beispiel zum Ändern von Text, Sortieren von Listen oder Berechnen von Werten. 
            Methoden werden immer mit Punktnotation aufgerufen, zum Beispiel <code>array.push()</code> oder <code>string.toUpperCase()</code>. 
            Durch Methoden kannst du deinen Code flexibler und einfacher gestalten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit ein paar Zahlen
const zahlen = [1, 2, 3];
            
// Methode push fügt ein neues Element ans Ende des Arrays an
zahlen.push(4);
            
console.log(zahlen); // Ausgabe: [1, 2, 3, 4]
            
// Ein String
const text = "hallo";
            
// Methode toUpperCase wandelt den Text in Grossbuchstaben um
const grossText = text.toUpperCase();
            
console.log(grossText); // Ausgabe: "HALLO"              
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="objects">Objekte</h1>
        <p>
            Objekte sind eines der wichtigsten Konzepte in JavaScript und dienen dazu, mehrere Werte oder Eigenschaften in einer einzigen Einheit zu speichern. 
            Ein Objekt besteht aus sogenannten Schlüssel-Wert-Paaren, wobei jeder Schlüssel (auch Property genannt) einen Wert haben kann – das können Zahlen, Texte, Funktionen oder sogar andere Objekte sein. 
            Mit Objekten kannst du Daten logisch strukturieren und organisieren, zum Beispiel Informationen über eine Person, ein Auto oder eine Bestellung. 
            Du greifst auf die Werte eines Objekts über die Punktnotation (<code>objekt.eigenschaft</code>) oder eckige Klammern (<code>objekt["eigenschaft"]</code>) zu. 
            Objekte sind die Grundlage für viele weitere JavaScript-Features, wie Methoden, Klassen oder JSON-Daten.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Objekt, das eine Person beschreibt
const person = {
    name: "Anna",
    alter: 28,
    beruf: "Designer",
  
    // Methode, die die Person begrüsst
    begruessung: function() {
        console.log("Hallo, mein Name ist " + this.name + ".");
    }
};

// Zugriff auf Eigenschaften
console.log(person.name);   // Ausgabe: Anna
console.log(person.alter);  // Ausgabe: 28

// Aufruf der Methode
person.begruessung();      // Ausgabe: Hallo, mein Name ist Anna.
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="arrays">Arrays</h1>
        <p>
            Arrays sind geordnete Sammlungen von Werten, die du unter einem einzigen Variablennamen speichern kannst. 
            Ein Array kann beliebig viele Elemente enthalten – zum Beispiel Zahlen, Zeichenketten, Objekte oder sogar andere Arrays. 
            Du greifst auf ein Element über seinen Index zu, der bei 0 beginnt (z. B. <code>meineArray[0]</code> für das erste Element). 
            Arrays sind dynamisch: Du kannst Elemente hinzufügen (<code>push</code>), entfernen (<code>pop</code>) oder in der Mitte einfügen (<code>splice</code>), ohne die ursprüngliche Grösse festlegen zu müssen. 
            Viele eingebaute Methoden wie <code>map</code>, <code>filter</code> oder <code>forEach</code> helfen dir, Daten elegant zu verarbeiten und zu transformieren. 
            Durch ihre Flexibilität und leistungsstarken Funktionen sind Arrays unverzichtbar für die Arbeit mit Listen und Sammlungen in JavaScript.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit Namen
const namen = ["Anna", "Ben", "Clara", "David"];
            
// Zugriff auf das erste Element (Index 0)
console.log(namen[0]);  // Ausgabe: Anna
            
// Ein neues Element hinzufügen
namen.push("Eva");
console.log(namen);  // Ausgabe: ["Anna", "Ben", "Clara", "David", "Eva"]
            
// Elemente durchlaufen und ausgeben
namen.forEach(function(name) {
    console.log("Hallo, " + name + "!");
});
            
// Filter: Alle Namen mit mehr als 3 Buchstaben
const langeNamen = namen.filter(name => name.length > 3);
console.log(langeNamen);  // Ausgabe: ["Clara", "David"]            
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="push">push</h1>
        <p>
            Die Methode <code>push()</code> ist eine praktische Funktion, mit der du neue Elemente ans Ende eines Arrays hinzufügen kannst. 
            Wenn du zum Beispiel eine Liste von Werten hast und dynamisch weitere Werte ergänzen möchtest, ist <code>push()</code> genau das richtige Werkzeug. 
            Dabei verändert <code>push()</code> das ursprüngliche Array direkt und gibt die neue Länge des Arrays zurück. 
            Das macht es besonders einfach, Arrays flexibel zu erweitern, ohne eine neue Variable anlegen zu müssen. 
            Kurz gesagt: Mit <code>push()</code> fügst du Elemente schnell und unkompliziert hinten an dein Array an.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit Zahlen
let zahlen = [1, 2, 3];
            
// Mit push() ein neues Element hinzufügen
zahlen.push(4);
            
console.log(zahlen);  // Ausgabe: [1, 2, 3, 4]
            
// Noch ein Element anhängen
zahlen.push(5);
            
console.log(zahlen);  // Ausgabe: [1, 2, 3, 4, 5]
            
// push() gibt die neue Länge des Arrays zurück
let neueLaenge = zahlen.push(6);
console.log(neueLaenge);  // Ausgabe: 6 
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="pop">pop</h1>
        <p>
            Die Methode <code>pop()</code> wird verwendet, um das letzte Element aus einem Array zu entfernen. 
            Dabei verändert <code>pop()</code> das ursprüngliche Array direkt und gibt das entfernte Element zurück. 
            Das ist besonders praktisch, wenn du Elemente vom Ende einer Liste entfernen möchtest, zum Beispiel in einer Stapelverarbeitung (Stack). 
            Wenn das Array leer ist, gibt <code>pop()</code> <code>undefined</code> zurück. 
            Kurz gesagt: Mit <code>pop()</code> kannst du ganz einfach das letzte Element aus einem Array herausholen und entfernen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit Farben
let farben = ['rot', 'grün', 'blau'];
            
// Das letzte Element entfernen und speichern
let letzteFarbe = farben.pop();
            
console.log(letzteFarbe); // Ausgabe: blau
console.log(farben);       // Ausgabe: ['rot', 'grün']
            
// Noch einmal pop() verwenden
let nochEineFarbe = farben.pop();
            
console.log(nochEineFarbe); // Ausgabe: grün
console.log(farben);        // Ausgabe: ['rot'] 
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="shift">shift</h1>
        <p>
            Die Methode <code>shift()</code> entfernt das erste Element aus einem Array und gibt dieses Element zurück. 
            Dabei wird das Array direkt verändert und alle übrigen Elemente rücken eine Position nach vorne. 
            Diese Methode ist nützlich, wenn du Elemente von Anfang eines Arrays entfernen möchtest, zum Beispiel in einer Warteschlange (Queue). 
            Wenn das Array leer ist, liefert <code>shift()</code> <code>undefined</code> zurück. 
            Mit <code>shift()</code> kannst du also leicht das erste Element aus einem Array herausnehmen und gleichzeitig das Array anpassen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit Früchten
let früchte = ['Apfel', 'Banane', 'Kirsche'];

// Das erste Element entfernen und speichern
let ersteFrucht = früchte.shift();

console.log(ersteFrucht);  // Ausgabe: Apfel
console.log(früchte);      // Ausgabe: ['Banane', 'Kirsche']

// Noch einmal shift() verwenden
let nächsteFrucht = früchte.shift();

console.log(nächsteFrucht); // Ausgabe: Banane
console.log(früchte);       // Ausgabe: ['Kirsche']
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="unshift">unshift</h1>
        <p>
            Die Methode <code>unshift()</code> fügt ein oder mehrere Elemente am Anfang eines Arrays hinzu. 
            Dabei werden die bestehenden Elemente nach hinten verschoben, um Platz für die neuen Elemente zu schaffen. 
            <code>unshift()</code> verändert also direkt das ursprüngliche Array. 
            Die Methode gibt die neue Länge des Arrays zurück, nachdem die Elemente eingefügt wurden. 
            <code>unshift()</code> ist praktisch, wenn du Elemente am Anfang eines Arrays ergänzen möchtest, zum Beispiel bei der Verwaltung von Warteschlangen oder Listen.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ein Array mit Tieren
let tiere = ['Hund', 'Katze', 'Vogel'];

// Ein neues Tier am Anfang hinzufügen
let neueLänge = tiere.unshift('Elefant');

console.log(tiere);       // Ausgabe: ['Elefant', 'Hund', 'Katze', 'Vogel']
console.log(neueLänge);   // Ausgabe: 4

// Noch ein Tier am Anfang einfügen
tiere.unshift('Maus');

console.log(tiere);       // Ausgabe: ['Maus', 'Elefant', 'Hund', 'Katze', 'Vogel']
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="map">map</h1>
        <p>
            Die Methode <code>map()</code> ist eine sehr nützliche Funktion, mit der du ein Array in ein neues Array umwandeln kannst. 
            Dabei wird auf jedes Element des ursprünglichen Arrays eine Funktion angewendet, die das Element verarbeitet oder verändert. 
            Das Ergebnis ist ein neues Array mit den veränderten Werten – das Original-Array bleibt dabei unverändert. 
            <code>map()</code> eignet sich gut, wenn du z. B. alle Werte umrechnen, filtern oder formatieren möchtest, ohne das ursprüngliche Array zu verändern.
        </p>
        <h2>Beispiel</h2>  
        <pre class="language-javascript"><code>
// Ursprüngliches Array mit Zahlen
const zahlen = [1, 2, 3, 4, 5];

// map() multipliziert jede Zahl mit 2 und erstellt ein neues Array
const verdoppelt = zahlen.map(function(num) {
  return num * 2;
});

console.log(verdoppelt); // Ausgabe: [2, 4, 6, 8, 10]
console.log(zahlen);     // Ausgabe: [1, 2, 3, 4, 5] (unverändert)
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="filter">filter</h1>
        <p>
            Die Methode <code>filter()</code> verwendet, um aus einem Array ein neues Array zu erstellen, das nur die Elemente enthält, die bestimmte Bedingungen erfüllen. 
            Dabei durchläuft <code>filter()</code> jedes Element im ursprünglichen Array und wendet eine Funktion an, die entscheidet, ob das Element im neuen Array enthalten sein soll oder nicht. 
            Das Original-Array bleibt dabei unverändert. 
            <code>filter()</code> ist ideal, wenn du gezielt nur bestimmte Werte aus einem Array herausfiltern möchtest, zum Beispiel alle Zahlen grösser als 10 oder alle Objekte mit einem bestimmten Attribut.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Ursprüngliches Array mit Zahlen
const zahlen = [5, 12, 8, 130, 44];
            
// filter() erstellt ein neues Array mit Zahlen grösser als 10
const grosseZahlen = zahlen.filter(function(num) {
    return num > 10;
});
            
console.log(grosseZahlen); // Ausgabe: [12, 130, 44]
console.log(zahlen);       // Ausgabe: [5, 12, 8, 130, 44] (unverändert) 
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="reduce">reduce</h1>
        <p>
            Die Methode <code>reduce()</code> ist eine leistungsstarke Funktion, mit der du ein Array auf einen einzigen Wert reduzieren kannst. 
            Sie durchläuft alle Elemente des Arrays und verarbeitet sie Schritt für Schritt mit einer sogenannten „Reducer“-Funktion. 
            Diese Funktion bekommt dabei einen Akkumulator (eine Art Zwischenergebnis) und das aktuelle Element als Eingabe und gibt einen neuen Akkumulator zurück. 
            Typische Anwendungsfälle sind das Berechnen von Summen, Produkten oder das Kombinieren von Daten aus einem Array. 
            Mit <code>reduce()</code> kannst du also komplexe Berechnungen elegant und effizient durchführen – und das alles in nur einer Zeile Code.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Beispiel: Summe aller Zahlen in einem Array berechnen
const zahlen = [1, 2, 3, 4, 5];
            
const summe = zahlen.reduce(function(akkumulator, aktuellesElement) {
    return akkumulator + aktuellesElement;
}, 0);
 
console.log(summe); // Ausgabe: 15 
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="getElementById">getElementById</h1>
        <p>
            Die Methode <code>getElementById()</code> ist eine einfache und häufig genutzte Funktion in JavaScript, mit der du ein einzelnes HTML-Element anhand seiner <code>id</code> auswählen kannst. 
            Du gibst einfach die <code>id</code> des gewünschten Elements als String an, und die Methode gibt dir dieses Element zurück – falls es existiert. 
            So kannst du direkt auf ein bestimmtes Element zugreifen, um dessen Inhalt zu ändern, es zu stylen oder mit ihm zu interagieren. 
            Das macht <code>getElementById()</code> zu einem praktischen Werkzeug für die Arbeit mit dynamischen Webseiten.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
// HTML-Element mit der ID "meinButton" auswählen
const button = document.getElementById("meinButton");
            
// Textinhalt des Buttons ändern
button.textContent = "Klick mich!";
            
// Eventlistener hinzufügen, der beim Klick eine Nachricht ausgibt
button.addEventListener("click", function() {
    alert("Der Button wurde gedrückt!");
});       
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;button id="meinButton"&gt;Originaltext&lt;/button&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="querySelector">querySelector</h1>
        <p>
            Die Methode <code>querySelector()</code> ist ein vielseitiges Werkzeug, mit dem du HTML-Elemente anhand von CSS-Selektoren auswählen kannst. 
            Im Gegensatz zu <code>getElementById()</code>, das nur nach der <code>id</code> sucht, kannst du mit <code>querySelector()</code> Elemente über Klassen, Tags, Attribute oder komplexe 
            Selektoren ansprechen. Sie gibt das erste Element zurück, das dem angegebenen Selektor entspricht, oder <code>null</code>, wenn kein passendes Element gefunden wurde. 
            So ermöglicht <code>querySelector()</code> sehr flexible und präzise Auswahlmöglichkeiten für die Arbeit mit dem DOM. 
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
// Das erste Element mit der Klasse "highlight" auswählen
const element = document.querySelector(".highlight");
            
// Den Textinhalt des ausgewählten Elements ändern
if (element) {
    element.textContent = "Dieser Text wurde geändert!";
}            
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;p class="highlight"&gt;Ursprünglicher Text&lt;/p&gt;
&lt;p&gt;Anderer Text&lt;/p&gt;       
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="innerHTML">innerHTML</h1>
        <p> Die Eigenschaft <code>innerHTML</code> erlaubt es dir, den HTML-Inhalt eines Elements als String zu lesen oder zu verändern. 
            Das bedeutet, du kannst damit den kompletten Inhalt eines Elements inklusive HTML-Tags dynamisch ändern oder neu setzen. 
            Das ist sehr praktisch, wenn du Inhalte auf einer Webseite ohne Neuladen aktualisieren möchtest. 
            Allerdings solltest du vorsichtig sein, wenn du <code>innerHTML</code> mit Benutzereingaben verwendest, da dadurch Sicherheitslücken wie Cross-Site Scripting (XSS) entstehen können. 
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
// JavaScript: Den HTML-Inhalt des Elements mit der ID "container" ändern
const container = document.getElementById("container");
container.innerHTML = "&lt;h2&gt;Neuer Titel&lt;/h2&gt;&lt;p&gt;Dieser Inhalt wurde mit innerHTML ersetzt.&lt;/p&gt;";          
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;div id="container"&gt;
    &lt;p&gt;Ursprünglicher Inhalt&lt;/p&gt;
&lt;/div&gt;              
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="textContent">textContent</h1>
        <p>
            <code>textContent</code> ist eine Eigenschaft, mit der du den reinen Textinhalt eines HTML-Elements auslesen oder ändern kannst. 
            Im Gegensatz zu <code>innerHTML</code> behandelt <code>textContent</code> den Inhalt rein als Text – HTML-Tags werden dabei nicht interpretiert oder gerendert. 
            Das macht <code>textContent</code> sicherer, wenn du Benutzereingaben anzeigen willst, da keine schädlichen oder unerwünschten HTML-Inhalte ausgeführt werden können. 
            Es ist eine einfache und schnelle Möglichkeit, Text in einem Element zu setzen oder zu lesen, ohne sich um HTML-Strukturen kümmern zu müssen.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
function aendereText() {
    // Holt das Element mit der ID "info" und ändert dessen Textinhalt
    document.getElementById("info").textContent = "Der Text wurde erfolgreich geändert.";
}
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;p id="info"&gt;Willkommen auf meiner Seite!&lt;/p&gt;
&lt;button onclick="aendereText()"&gt;Text ändern&lt;/button&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="style">style</h1>
        <p>
            Mit der <code>style</code> Eigenschaft in JavaScript kannst du direkt auf die CSS-Stile eines HTML-Elements zugreifen und diese verändern. 
            Das ist besonders nützlich, wenn du das Aussehen einer Seite dynamisch anpassen willst – z. B. beim Klick auf einen Button oder bei bestimmten Benutzeraktionen. 
            Du kannst über <code>element.style.eigenschaft</code> z. B. Farben ändern, Abstände setzen oder Elemente ein- und ausblenden. 
            Beachte dabei, dass du CSS-Eigenschaften wie <code>background-color</code> in JavaScript im camelCase-Stil schreiben musst: <code>backgroundColor</code>.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>script.js</h3>
        <pre class="language-javascript"><code>
function färbeText() {
    const p = document.getElementById("text");
    p.style.color = "red";               // Textfarbe ändern
    p.style.fontWeight = "bold";         // Fett darstellen
    p.style.backgroundColor = "#f0f0f0"; // Hintergrundfarbe ändern
}
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;p id="text"&gt;Klicke den Button, um mich rot zu färben!&lt;/p&gt;
&lt;button onclick="färbeText()"&gt;Färbe den Text&lt;/button&gt;
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="addEventListener">addEventListener</h1>
        <p>
            Die Methode <code>addEventListener()</code> ist ein zentrales Werkzeug, um Webseiten interaktiv zu gestalten. 
            Mit ihr kannst du gezielt auf Benutzeraktionen wie Mausklicks, Tastatureingaben oder das Laden der Seite reagieren. 
            Du übergibst dabei den Namen des Events (z. B. <code>'click'</code>), eine Callback-Funktion, die beim Eintreten des Ereignisses ausgeführt wird, und optional weitere Einstellungen. 
            Der grosse Vorteil von <code>addEventListener()</code> ist, dass du mehrere Event-Listener auf dasselbe Element setzen kannst, ohne vorhandene zu überschreiben. 
            Damit ermöglicht es dir, sauberen, modularen und wiederverwendbaren Code zu schreiben – ein Muss für moderne Webentwicklung.
        </p>
        <h2>Beispiel</h2>        
        <br>
        <h3>script.js</h3>
        <pre><code class="language-javascript">
// Beispiel: Klick auf einen Button auswerten
const button = document.getElementById('meinButton');
            
button.addEventListener('click', () => {
    alert('Du hast den Button geklickt!');
});
        </code></pre>
        <br>
        <h3>index.html</h3>
        <pre class="language-html"><code>
&lt;button id="meinButton"&gt;Klick mich!&lt;/button&gt;
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="async">async</h1>
        <p>
            Das Schlüsselwort <code>async</code> wird verwendet, um Funktionen zu deklarieren, die asynchron arbeiten. 
            Es ermöglicht dir, mit <code>await</code> auf Promises zu warten, ohne komplexe <code>.then()</code>-Ketten schreiben zu müssen. 
            Eine <code>async</code>-Funktion gibt immer ein Promise zurück, selbst wenn du darin scheinbar normalen Code ausführst. 
            Mit <code>await</code> kannst du dann innerhalb der Funktion auf das Ergebnis eines Promises warten, ohne den Programmfluss zu unterbrechen – das macht den Code übersichtlicher und näher an synchronem Denken. 
            Besonders nützlich ist <code>async/await</code> beim Arbeiten mit APIs, Timern oder anderen Vorgängen, die Zeit benötigen – und das ganz ohne „Callback-Hölle“.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Beispiel: Daten von einer API laden und anzeigen
async function ladeBenutzer() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
        const benutzer = await response.json();
        console.log('Benutzername:', benutzer.name);
    } catch (error) {
        console.error('Fehler beim Laden:', error);
    }
}
                
ladeBenutzer();
        </code></pre>    

        <br>
        <br>
        <br>

        <h1 id="await">await</h1>
        <p>
            Das Schlüsselwort <code>await</code> wird verwendet, um auf die Auflösung eines Promises zu warten – und das auf eine besonders lesbare und verständliche Weise. 
            Es darf nur innerhalb von <code>async</code>-Funktionen verwendet werden und pausiert dort die Ausführung, bis das Promise einen Wert zurückgibt oder ein Fehler auftritt. 
            Dadurch wirkt der Code fast so, als wäre er synchron, obwohl er im Hintergrund weiterhin nicht blockierend arbeitet. 
            <code>await</code> ist ideal, um Schritt für Schritt auf Ergebnisse zu warten, z. B. beim Laden von Daten, Abwarten von Timern oder anderen zeitabhängigen Prozessen. 
            Es macht deinen Code einfacher zu lesen, vermeidet verschachtelte <code>.then()</code>-Ketten und reduziert so die Fehleranfälligkeit deutlich.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Funktion, die ein Promise mit künstlichem Delay zurückgibt
function warte(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
            
async function beispiel() {
    console.log('Starte...');
    await warte(2000);  // wartet 2 Sekunden
    console.log('2 Sekunden sind vorbei!');
}
            
beispiel();
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="trycatch">try... catch</h1>
        <p>
            Die <code>try...catch</code>-Anweisung ist ein wichtiges Werkzeug zum Umgang mit Fehlern. 
            Mit <code>try</code> kannst du einen Codeblock umgeben, bei dem du mit möglichen Fehlern rechnest, ohne dass das gesamte Programm abstürzt. 
            Tritt im <code>try</code>-Block ein Fehler auf, wird die Ausführung sofort unterbrochen und in den <code>catch</code>-Block gesprungen, wo du den Fehler abfangen und darauf reagieren kannst. 
            So kannst du beispielsweise Fehlermeldungen ausgeben, alternative Abläufe starten oder Fehler protokollieren. 
            <code>try...catch</code> macht deinen Code robuster und sorgt für eine bessere Nutzererfahrung, da unerwartete Probleme elegant behandelt werden.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Beispiel: Fehler beim Parsen von JSON abfangen
const jsonString = '&lcub; "name": "Nathan", "age": 16 '; // Fehlerhafte JSON (fehlende schliessende Klammer)
            
try {
    const user = JSON.parse(jsonString);
    console.log('Name:', user.name);
} catch (error) {
    console.error('Fehler beim Parsen der JSON:', error.message);
}
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="class">class</h1>
        <p>
            Mit der <code>class</code>-Syntax kannst du eigene Baupläne für Objekte erstellen. 
            Klassen sind eine elegante Möglichkeit, um Objekte mit Eigenschaften und Methoden zu definieren und mehrfach zu verwenden. 
            Sie basieren auf Prototypen, machen die Objektorientierung aber viel übersichtlicher und moderner. 
            In einer Klasse kannst du einen <code>constructor</code> definieren, der beim Erzeugen eines neuen Objekts automatisch aufgerufen wird, sowie verschiedene Methoden, die das Verhalten der Objekte beschreiben. 
            Klassen erleichtern es, komplexe Programme strukturiert und wiederverwendbar zu gestalten.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Beispiel: Eine einfache Klasse "Person"
class Person {
    constructor(name, alter) {
        this.name = name;
        this.alter = alter;
    }
            
    vorstellen() {
        console.log(`Hallo, ich heisse ${this.name} und bin ${this.alter} Jahre alt.`);
    }
}
            
// Objekt erstellen und Methode aufrufen
const max = new Person('Max', 23);
max.vorstellen();
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="constructor">constructor</h1>
        <p>
            Der <code>constructor</code> ist eine spezielle Methode innerhalb einer Klasse, die automatisch aufgerufen wird, wenn ein neues Objekt dieser Klasse erstellt wird. 
            Er dient dazu, die Anfangswerte der Eigenschaften eines Objekts festzulegen und das Objekt zu initialisieren. 
            Im <code>constructor</code> kannst du Parameter übergeben, die beim Erzeugen des Objekts benötigt werden, und diese Werte dann auf die Instanzvariablen (<code>this</code>) setzen. 
            So stellst du sicher, dass jedes Objekt individuell mit den richtigen Daten startet. 
            Der <code>constructor</code> ist damit das Herzstück jeder Klasse und sorgt für eine saubere und flexible Objekterstellung.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Beispiel: Klasse mit constructor
class Auto {
    constructor(markemodell, baujahr) {
        this.markemodell = markemodell;
        this.baujahr = baujahr;
    }
            
    beschreibung() {
        console.log(`Dieses Auto ist ein ${this.markemodell} aus dem Jahr ${this.baujahr}.`);
    }
}
            
// Neues Auto-Objekt erstellen
const meinAuto = new Auto('Tesla Model 3', 2023);
meinAuto.beschreibung();
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="extends">extends</h1>
        <p>
            Mit dem Schlüsselwort <code>extends</code> kannst du eine Klasse von einer anderen Klasse erben lassen. 
            Dadurch übernimmt die neue Klasse automatisch alle Eigenschaften und Methoden der Basisklasse und kann zusätzlich eigene Funktionen definieren oder bestehende überschreiben. 
            Das ist besonders praktisch, wenn du ähnliche Objekte mit leicht unterschiedlichem Verhalten erstellen möchtest, ohne Code zu duplizieren. 
            Die Vererbung mit <code>extends</code> fördert saubere, strukturierte und wiederverwendbare Codearchitektur – ein zentrales Prinzip der objektorientierten Programmierung.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Basisklasse
class Tier {
    constructor(name) {
        this.name = name;
    }
        
    sprich() {
        console.log(`${this.name} macht ein Geräusch.`);
    }
}
        
// Unterklasse, die von Tier erbt
class Hund extends Tier {
    constructor(name, rasse) {
        super(name); // ruft den constructor der Basisklasse auf
        this.rasse = rasse;
    }
        
    sprich() {
        console.log(`${this.name} bellt. (${this.rasse})`);
    }
}
        
// Objekt erstellen und Methoden verwenden
const meinHund = new Hund('Bello', 'Labrador');
meinHund.sprich(); // Ausgabe: Bello bellt. (Labrador)
        </code></pre>

        <br>
        <br>
        <br>
        
        <h1 id="super">super</h1>
        <p>
            Das Schlüsselwort <code>super</code> wird verwendet, um auf die Elternklasse einer erbenden Klasse zuzugreifen. 
            Innerhalb des <code>constructor</code> einer Unterklasse musst du <code>super(...)</code> aufrufen, bevor du auf <code>this</code> zugreifen kannst – dadurch wird der Konstruktor der Basisklasse ausgeführt. 
            Ausserdem kannst du mit <code>super</code> Methoden der Elternklasse aufrufen, etwa wenn du eine Methode erweitern, aber nicht vollständig überschreiben möchtest. 
            <code>super</code> ist also zentral für das Arbeiten mit Vererbung und hilft dir, die Logik der Elternklasse gezielt weiterzuverwenden.
        </p>
        <h2>Beispiel</h2>
        <pre><code class="language-javascript">
// Basisklasse
class Fahrzeug {
    constructor(marke) {
        this.marke = marke;
    }
        
    starten() {
        console.log(`${this.marke} startet den Motor.`);
    }
}
        
// Unterklasse
class Auto extends Fahrzeug {
    constructor(marke, modell) {
        super(marke);                   // ruft den Konstruktor der Elternklasse auf
        this.modell = modell;
    }
        
    starten() {
        super.starten();                // ruft die Methode der Elternklasse auf
        console.log(`${this.marke} ${this.modell} fährt los.`);
    }
}
        
// Objekt erstellen
const meinAuto = new Auto('Tesla', 'Model 3');
meinAuto.starten();
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="import">import</h1>
        <p>
            Mit dem Schlüsselwort <code>import</code> kannst du Funktionen, Klassen, Variablen oder ganze Module aus anderen Dateien einbinden. 
            Das fördert sauberen, modularen Code, da du Funktionen und Logik in mehrere Dateien aufteilen kannst. 
            Die <code>import</code>-Syntax funktioniert nur in sogenannten ES6-Modulen, die mit <code>export</code> definiert wurden. 
            Je nach Bedarf kannst du einzelne Funktionen gezielt importieren oder ein ganzes Modul unter einem Namen laden. 
            So wird dein Code übersichtlicher, wartbarer und besser strukturiert – besonders bei grösseren Projekten.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>mathe.js</h3>
        <pre class="language-javascript"><code>
// Funktionen exportieren
export function addiere(a, b) {
    return a + b;
}
            
export function multipliziere(a, b) {
    return a * b;
}     
        </code></pre>
        <br>
        <h3>main.js</h3>
        <pre class="language-javascript"><code>
// Funktionen aus mathe.js importieren
import { addiere, multipliziere } from './mathe.js';

console.log(addiere(3, 4));        // 7
console.log(multipliziere(3, 4));  // 12
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="export">export</h1>
        <p>
            Mit dem Schlüsselwort <code>export</code> kannst du Funktionen, Variablen oder Klassen aus einer Datei freigeben, damit sie in anderen Dateien mit <code>import</code> verwendet werden können. 
            So lässt sich dein Code modular aufbauen und besser organisieren. 
            Du kannst einzelne Elemente gezielt mit <code>export</code> markieren oder einen Standard-Export mit <code>export default</code> verwenden. 
            Besonders in grösseren Projekten hilft <code>export</code> dabei, Wiederverwendbarkeit und klare Strukturen zu schaffen – ganz im Sinne von sauberem, wartbarem Code.
        </p>
        <h2>Beispiel</h2>
        <br>
        <h3>utils.js</h3>
        <pre class="language-javascript"><code>
// Einzelne benannte Exporte
export function begruessung(name) {
    return `Hallo, ${name}!`;
}
            
export const version = '1.0.0';            
        </code></pre>
        <br>
        <h3>main.js</h3>
        <pre class="language-javascript"><code>
// Funktionen und Variablen importieren
import { begruessung, version } from './utils.js';

console.log(begruessung('Andreas')); // Hallo, Andreas!
console.log('Version:', version);   // Version: 1.0.0
        </code></pre>
        <h2>Beispiel mit export default</h2>
        <br>
        <h3>rechner.js</h3>
        <pre class="language-javascript"><code>
// Standard-Export
export default function quadriere(x) {
    return x * x;
}
        </code></pre>
        <br>
        <h3>main.js</h3>
        <pre class="language-javascript"><code>
// Import des Standard-Exports
import quadriere from './rechner.js';

console.log(quadriere(5)); // 25
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="fetch">fetch</h1>
        <p>
            Die <code>fetch</code>-Funktion wird verwendet, um HTTP-Anfragen an Server zu senden – zum Beispiel um Daten von einer API abzurufen. 
            Sie basiert auf Promises und ermöglicht es dir, asynchron auf Webressourcen zuzugreifen, ohne die Seite neu zu laden. 
            Mit <code>fetch</code> kannst du GET-, POST- und andere HTTP-Methoden verwenden. 
            Die Antwort muss in der Regel zuerst mit <code>.json()</code> oder <code>.text()</code> weiterverarbeitet werden. 
            <code>fetch</code> ist ein leistungsfähiges Werkzeug, um moderne Webanwendungen mit externen Datenquellen zu verbinden.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Daten von einer öffentlichen API abrufen
fetch('https://api.example.com/user/123')
    .then(response => {
        if (!response.ok) {
            throw new Error('Netzwerkfehler: ' + response.status);
        }
        return response.json(); // Antwort als JSON parsen
    })
    .then(data => {
        console.log('Benutzerdaten:', data);
    })
    .catch(error => {
        console.error('Fehler beim Abrufen:', error.message);
    });
        </code></pre>
        
        <br>
        <br>
        <br>

        <h1 id="XMLHttpRequest">XMLHttpRequest</h1>
        <p>
            <code>XMLHttpRequest</code> ist eine ältere JavaScript-API, mit der du HTTP-Anfragen an einen Server senden kannst. 
            Sie war lange Zeit die Standardmethode für das Laden von Daten im Hintergrund (AJAX), bevor <code>fetch</code> eingeführt wurde. 
            Mit <code>XMLHttpRequest</code> kannst du GET-, POST- und andere Anfragen senden, um z. B. JSON-Daten von APIs zu laden. 
            Die Verwendung ist etwas umständlicher als bei <code>fetch</code>, funktioniert aber auch in älteren Browsern und wird teilweise noch in bestehenden Projekten verwendet.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// XMLHttpRequest verwenden, um Daten zu laden
const xhr = new XMLHttpRequest();

xhr.open('GET', 'https://api.example.com/user/123', true); // true = asynchron

xhr.onload = function () {
    if (xhr.status === 200) {
        const daten = JSON.parse(xhr.responseText);
        console.log('Benutzerdaten:', daten);
    } else {
        console.error('Fehler beim Laden:', xhr.status);
    }
};

xhr.onerror = function () {
    console.error('Netzwerkfehler oder Server nicht erreichbar.');
};

xhr.send();
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="localStorage">localStorage</h1>
        <p>
            <code>localStorage</code> ist eine Web-API, mit der du Daten dauerhaft im Browser des Benutzers speichern kannst – sogar über das Schließen des Tabs oder Browsers hinaus. 
            Die Daten werden als einfache Schlüssel-Wert-Paare gespeichert, wobei sowohl Schlüssel als auch Werte als Strings vorliegen müssen. 
            <code>localStorage</code> eignet sich hervorragend für kleine, einfache Daten wie Einstellungen, Favoriten oder Sitzungsinformationen. 
            Der Zugriff erfolgt synchron und ist super einfach mit <code>setItem()</code>, <code>getItem()</code> und <code>removeItem()</code>.
        </p>
        <h2>Beispiel</h2>
        <pre class="language-javascript"><code>
// Einen Wert speichern
localStorage.setItem('benutzername', 'Nathan');
            
// Einen Wert auslesen
const name = localStorage.getItem('benutzername');
console.log('Hallo,', name); // Ausgabe: Hallo, Nathan
            
// Einen Wert löschen
localStorage.removeItem('benutzername');
            
// Alle gespeicherten Daten löschen
localStorage.clear(); 
        </code></pre>

        <br>
        <br>
        <br>

        <h1 id="sessionStorage">sessionStorage</h1>
        <p>
            <code>sessionStorage</code> ist eine Web-API, mit der du Daten im Browser speichern kannst, die nur während einer einzelnen Sitzung erhalten bleiben. 
            Im Gegensatz zu <code>localStorage</code> werden die gespeicherten Daten gelöscht, sobald der Tab oder das Browserfenster geschlossen wird. 
            <code>sessionStorage</code> eignet sich gut für temporäre Informationen wie Zwischenstände in Formularen oder Benutzereinstellungen, die nicht dauerhaft erhalten bleiben sollen. 
            Der Zugriff funktioniert genauso wie bei <code>localStorage</code>, über <code>setItem()</code>, <code>getItem()</code> und <code>removeItem()</code>.
        </p>
        <h2>Beispiel</h2>
        <pre id="sessionStorage"><code>
// Einen Wert für die aktuelle Sitzung speichern
sessionStorage.setItem('sprache', 'de');

// Wert abrufen
const sprache = sessionStorage.getItem('sprache');
console.log('Sprache gewählt:', sprache); // Ausgabe: Sprache gewählt: de

// Wert entfernen
sessionStorage.removeItem('sprache');

// Alle Sitzungseinträge löschen
sessionStorage.clear();
        </code></pre>
    </main>

    <script>
        function scrollNav(amount) {
            document.getElementById('navWrapper').scrollBy({ left: amount, behavior: 'smooth' });
        }
    </script>
</body>
</html>